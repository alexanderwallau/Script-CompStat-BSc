<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Computer-Aided Statistical Analysis (B.Sc.) - 6&nbsp; Linear Model Selection and Regularization</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Ch5_ResamplingMethods.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Linear Model Selection and Regularization</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./" class="sidebar-logo-link">
      <img src="./images/Uni_Bonn_Logo.jpeg" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Computer-Aided Statistical Analysis (B.Sc.)</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Organization of the Course</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Ch2_StatLearning.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Statistical Learning</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Ch3_LinearRegression.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Linear Regression</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Ch4_Classification.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Classification</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Ch5_ResamplingMethods.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Resampling Methods</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Ch6_LinModSelectRegul.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Linear Model Selection and Regularization</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#ch.-6.1-subset-selection" id="toc-ch.-6.1-subset-selection" class="nav-link active" data-scroll-target="#ch.-6.1-subset-selection">(Ch. 6.1) Subset Selection</a>
  <ul class="collapse">
  <li><a href="#ch.-6.1.1-best-subset-selection" id="toc-ch.-6.1.1-best-subset-selection" class="nav-link" data-scroll-target="#ch.-6.1.1-best-subset-selection">(Ch. 6.1.1) Best Subset Selection</a></li>
  <li><a href="#ch.-6.1.2-stepwise-selection" id="toc-ch.-6.1.2-stepwise-selection" class="nav-link" data-scroll-target="#ch.-6.1.2-stepwise-selection">(Ch. 6.1.2) Stepwise Selection</a></li>
  </ul></li>
  <li><a href="#ch.-6.2-shrinkage-methods" id="toc-ch.-6.2-shrinkage-methods" class="nav-link" data-scroll-target="#ch.-6.2-shrinkage-methods">(Ch. 6.2) Shrinkage Methods</a>
  <ul class="collapse">
  <li><a href="#ch.-6.2.1-ridge-regression" id="toc-ch.-6.2.1-ridge-regression" class="nav-link" data-scroll-target="#ch.-6.2.1-ridge-regression">(Ch. 6.2.1) Ridge Regression</a></li>
  <li><a href="#why-and-when-does-ridge-regression-improve-over-least-squares" id="toc-why-and-when-does-ridge-regression-improve-over-least-squares" class="nav-link" data-scroll-target="#why-and-when-does-ridge-regression-improve-over-least-squares">Why and When Does Ridge Regression Improve Over Least Squares?</a></li>
  </ul></li>
  <li><a href="#ch.-6.2.2-the-lasso" id="toc-ch.-6.2.2-the-lasso" class="nav-link" data-scroll-target="#ch.-6.2.2-the-lasso">(Ch. 6.2.2) The Lasso</a>
  <ul class="collapse">
  <li><a href="#ch.-6.2.3-selecting-the-tuning-parameter" id="toc-ch.-6.2.3-selecting-the-tuning-parameter" class="nav-link" data-scroll-target="#ch.-6.2.3-selecting-the-tuning-parameter">(Ch. 6.2.3) Selecting the Tuning Parameter</a></li>
  </ul></li>
  <li><a href="#ch.-6.3-dimension-reduction-methods" id="toc-ch.-6.3-dimension-reduction-methods" class="nav-link" data-scroll-target="#ch.-6.3-dimension-reduction-methods">(Ch. 6.3) Dimension Reduction Methods</a>
  <ul class="collapse">
  <li><a href="#ch.-6.3.1-principal-components-regression" id="toc-ch.-6.3.1-principal-components-regression" class="nav-link" data-scroll-target="#ch.-6.3.1-principal-components-regression">(Ch. 6.3.1) Principal Components Regression</a></li>
  <li><a href="#the-principal-components-regression-approach" id="toc-the-principal-components-regression-approach" class="nav-link" data-scroll-target="#the-principal-components-regression-approach">The Principal Components Regression Approach</a></li>
  </ul></li>
  <li><a href="#r-lab-linear-model-selection-and-regularization" id="toc-r-lab-linear-model-selection-and-regularization" class="nav-link" data-scroll-target="#r-lab-linear-model-selection-and-regularization"><span class="toc-section-number">6.1</span>  <code>R</code>-Lab: Linear Model Selection and Regularization</a>
  <ul class="collapse">
  <li><a href="#subset-selection-methods" id="toc-subset-selection-methods" class="nav-link" data-scroll-target="#subset-selection-methods"><span class="toc-section-number">6.1.1</span>  Subset Selection Methods</a></li>
  <li><a href="#ridge-regression-and-the-lasso" id="toc-ridge-regression-and-the-lasso" class="nav-link" data-scroll-target="#ridge-regression-and-the-lasso"><span class="toc-section-number">6.1.2</span>  Ridge Regression and the Lasso</a></li>
  <li><a href="#pcr-and-pls-regression" id="toc-pcr-and-pls-regression" class="nav-link" data-scroll-target="#pcr-and-pls-regression"><span class="toc-section-number">6.1.3</span>  PCR and PLS Regression</a></li>
  </ul></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="toc-section-number">6.2</span>  Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Linear Model Selection and Regularization</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<p>Lecture videos:</p>
<ul>
<li><a href="">1. Video on Dimension Reduction</a></li>
<li><a href="">2. Video on Dimension Reduction</a></li>
<li><a href="">3. Video on Dimension Reduction</a></li>
</ul>
<p>In this chapter, we revisit the linear regression model <span class="math display">\[
Y = \beta_0 + \beta_1 X_1 + \dots + \beta_p X_p + \epsilon.
\]</span> In Chapter <a href="Ch3_LinearRegression.html"><span>Chapter&nbsp;3</span></a>, we focused on fitting a given linear regression model using least squares and completely ignored the model selection process. However, selecting a “good” model is itself a statistical problem which we need to solve using reliable statistical procedures. In this chapter, we consider fitting procedures that integrate the model selection process.</p>
<p>We discuss three important classes of methods:</p>
<ul>
<li><strong>Subset Selection.</strong> This approach involves identifying a subset of the <span class="math inline">\(p\)</span> predictors (from a large set of potential predictors) that we believe to be related to the response <span class="math inline">\(Y\)</span>. We then fit a model using least squares on the identified subset of predictors.</li>
<li><strong>Shrinkage/Regularization.</strong> This approach involves fitting a model involving all <span class="math inline">\(p\)</span> predictors—possibly with <span class="math inline">\(p\gg n\)</span>, where least squares does not work anymore. However, the coefficient estimates are shrunken towards zero relative to the least squares estimates. This shrinkage (also known as regularization) has the effect of reducing variance, but increasing bias. Depending on what type of shrinkage is performed, some of the coefficients may be estimated to be exactly zero. In this case, shrinkage methods can also perform variable selection.</li>
<li><strong>Dimension Reduction.</strong> This approach involves projecting the <span class="math inline">\(p\)</span> predictors into an <span class="math inline">\(M\)</span>-dimensional subspace, where <span class="math inline">\(M&lt;p\)</span>. Then these <span class="math inline">\(M\)</span> projections are used as predictors to fit a linear regression model by least squares.</li>
</ul>
<!-- This is achieved by computing $M$ different linear combinations, or projections, of the variables.  -->
<section id="ch.-6.1-subset-selection" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="ch.-6.1-subset-selection">(Ch. 6.1) Subset Selection</h2>
<p>In the following, we consider linear models with some large set of <span class="math inline">\(p\)</span> many potentially relevant predictors <span class="math inline">\(X=(X_1,\dots,X_{p}),\)</span> <span id="eq-modelLarge"><span class="math display">\[
\begin{align*}
Y
&amp;=\mathcal{M}_{p}(X) + \epsilon\\
&amp;=\beta_0 + \beta_1 X_1 + \dots + \beta_p X_{p} + \epsilon,
\end{align*}
\tag{6.1}\]</span></span> where <span class="math inline">\(Var(\epsilon)=\sigma^2,\)</span> and where <span class="math inline">\(\epsilon\)</span> is independent of the predictors <span class="math inline">\(X.\)</span></p>
<p>Let’s assume that only <span class="math inline">\(k\leq p\)</span> many predictors in <a href="#eq-modelLarge">Equation&nbsp;<span>6.1</span></a> are actually relevant having non-zero slope coefficients <span class="math inline">\(|\beta_j|&gt;0,\)</span> and let denote the index set of these relevant predictors by<br>
<span class="math display">\[
\mathcal{I}^*_{k^*}\subset\{1,2,\dots,p\}\quad\text{with}\quad |\mathcal{I}^*_{k^*}|=k^*\leq p.
\]</span></p>
<p>In (linear) model selection, one often aims to select the sub-model <span class="math display">\[
\mathcal{M}_{\mathcal{I}^*_{k^*}}(X)=\beta_0 + \sum_{j\in\mathcal{I}^*_{k^*}}\beta_j X_j
\]</span> containing all relevant predictors with coefficients <span class="math inline">\(|\beta_j|&gt;0.\)</span></p>
<p><!-- which contains all predictors with non-zero slope coefficients and no predictor with a zero slope coefficient.  --></p>
<!-- In the following we will make use of **information criteria**  -->
<p>A first idea may be to select candidate models <span class="math inline">\(\mathcal{M}_{\mathcal{I}_k}(X)\)</span> by maximizing the fit to the data; i.e.&nbsp;by maximizing the <span class="math inline">\(R^2\)</span> or equivalently by minimizing the Residual Sum of Squares (RSS), <span class="math display">\[
\begin{align*}
\operatorname{RSS}_k&amp;=\sum_{i=1}^n\left(y_i - \widehat{\mathcal{M}}_{\mathcal{I}_k}(X)\right)^2\\
%R^2_p &amp;=1-\frac{\operatorname{RSS}_p}{TSS}\\
\widehat{\mathcal{M}}_{\mathcal{I}_k}(X) &amp; = \hat\beta_0 + \sum_{j\in\mathcal{I}_k}\hat\beta_j X_j,  
%TSS&amp;=\sum_{i=1}^n\left(y_i - \bar{y}\right)^2.
\end{align*}
\]</span> where <span class="math inline">\(\mathcal{I}_k\)</span> is some candidate sub-set <span class="math inline">\(\mathcal{I}_k\subset\{1,2,\dots,p\}\)</span> with <span class="math inline">\(|\mathcal{I}_k|=k\leq p.\)</span></p>
<p>While this strategy can be used for selecting the best fitting model among all <span class="math display">\[
\binom{p}{k}=\frac{p!}{k!(p-k)!}
\]</span> many models with <span class="math inline">\(k\)</span> parameters, it fails to select the best fitting model with different numbers of parameters. Indeed, one can show that the “fit” of the model can be always increased by adding more predictors; i.e.&nbsp; <span class="math display">\[
\operatorname{RSS}_k\geq \operatorname{RSS}_{k'}\quad\text{for}\quad k&lt;k'.
\]</span> Thus, we need alternative criteria to choose between models with different numbers of regressors <span class="math inline">\(k\neq k'\)</span>.</p>
<p>In order to select the best model with respect to test error, we need to estimate this test error. There are two common approaches:</p>
<ol type="1">
<li>We can directly estimate the test error, using the validation set approach or cross-validation (<a href="Ch5_ResamplingMethods.html"><span>Chapter&nbsp;5</span></a>).</li>
<li>We can <em>indirectly</em> estimate test error by making an adjustment to the training error to account for the bias due to overfitting.</li>
</ol>
<p>The latter option is accomplished using information criteria such as, for instance, Mellow’s <span class="math inline">\(C_p\)</span>, Akaike Information Criterion (AIC), Bayesian Information Criterion (BIC), and the adjusted <span class="math inline">\(R^2.\)</span> Information criteria are particularly useful in cases, where cross-validation is computationally too expensive.</p>
<section id="mellows-c_p" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="mellows-c_p">Mellow’s <span class="math inline">\(C_p\)</span></h4>
<p><span id="eq-MCp"><span class="math display">\[
C_p \equiv C_p(k) = \frac{1}{n}\left(\operatorname{RSS}_k+2k\hat\sigma^2\right),
\tag{6.2}\]</span></span> where <span class="math inline">\(\hat\sigma^2=\frac{1}{n-p}\sum_{i=1}^n(y_i - \widehat{\mathcal{M}}_{p}(X))^2\)</span> is the sample variance of the residuals from the large model <a href="#eq-modelLarge">Equation&nbsp;<span>6.1</span></a> with all <span class="math inline">\(p\)</span> predictors, and where <span class="math inline">\(\operatorname{RSS}_k\)</span> are the RSS of the estimated model <span class="math inline">\(\widehat{\mathcal{M}}_{\mathcal{I}_k}(X)\)</span> with <span class="math inline">\(k\leq p\)</span> predictors.</p>
<p>Under certain regularity assumptions, one can show that <span class="math inline">\(C_p\)</span> is an unbiased estimate of the test MSE. The best model is the one which has the lowest <span class="math inline">\(C_p\)</span> value.</p>
</section>
<section id="the-aic" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="the-aic">The AIC</h4>
<p>The AIC is defined for a large class of models fit by maximum likelihood. If the error terms in the linear regression model <a href="#eq-modelLarge">Equation&nbsp;<span>6.1</span></a> are Gaussian, maximum likelihood and least squares estimation are equivalent. In this case AIC is given by <span class="math display">\[
\operatorname{AIC} \equiv \operatorname{AIC}(k) = \frac{1}{n}\left(\operatorname{RSS}_k + 2 k\hat\sigma^2\right),
\]</span> where <span class="math inline">\(\hat\sigma^2\)</span> is defined as in <a href="#eq-MCp">Equation&nbsp;<span>6.2</span></a>. The above formula for the AIC omits factors that are constant in <span class="math inline">\(k\)</span> and thus irrelevant for model selection. Hence for least squares the AIC and Mellow’s <span class="math inline">\(C_p\)</span> are proportional to each other, and thus lead to the same model choices.</p>
</section>
<section id="the-bic" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="the-bic">The BIC</h4>
<p><span class="math display">\[
\operatorname{BIC} \equiv \operatorname{BIC}(k) = \frac{1}{n}\left(\operatorname{RSS}_k + \log(n)2 k\hat\sigma^2\right)
\]</span> where <span class="math inline">\(\hat\sigma^2\)</span> is defined as in <a href="#eq-MCp">Equation&nbsp;<span>6.2</span></a>.</p>
<p>Since <span class="math inline">\(\log(n)&gt;2\)</span> for any sample size <span class="math inline">\(n&gt;7,\)</span> the BIC statistic generally places a heavier penalty on models with many predictors, and hence results in the selection of smaller models than Mellow’s <span class="math inline">\(C_p\)</span> and AIC.</p>
</section>
<section id="the-adjusted-r2" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="the-adjusted-r2">The adjusted <span class="math inline">\(R^2\)</span></h4>
<p><span class="math display">\[
\operatorname{adjusted } R^2 \equiv (\operatorname{adjusted } R^2)(k) = 1-\frac{\operatorname{RSS}_k/(n-k-1)}{\operatorname{TSS}/(n-1)},
\]</span> where <span class="math inline">\(\operatorname{TSS}=\sum_{i=1}^n\left(y_i - \bar{y}\right)^2.\)</span></p>
<p>Unlike Mellow’s <span class="math inline">\(C_p,\)</span> AIC, and BIC, <strong>large values</strong> of <span class="math inline">\(\operatorname{adjusted } R^2\)</span> indicate models with low test errors.</p>
<p>Note that maximizing <span class="math inline">\(\operatorname{adjusted } R^2\)</span> is equivalent to minimizing <span class="math inline">\(\operatorname{RSS}_k/(n-k-1).\)</span> While <span class="math inline">\(\operatorname{RSS}_k\)</span> is a decreasing function of <span class="math inline">\(k,\)</span> <span class="math inline">\(\operatorname{RSS}_k/(n-k-1)\)</span> may decrease or increase when increasing <span class="math inline">\(k,\)</span> depending on the amount of RSS-reduction due to the added predictors.</p>
<p><strong>Note:</strong> Mellow’s <span class="math inline">\(C_p,\)</span> AIC, and BIC have rigorous theoretical justifications. The <span class="math inline">\(\operatorname{adjusted } R^2\)</span> is not es well motivated by statistical theory.</p>
<!-- Since $\mathcal{I}^*_{k^*}\subset \mathcal{I}_p$, $\hat\sigma^2$ is an unbiased estimator of $\sigma^2$, i.e.
$$
E(\hat\sigma^2) = \sigma^2.
$$

Moreover, for every large enough index set $\mathcal{I}_k$ such that $\mathcal{I}^*_{k^*}\subset \mathcal{I}_k$, we have that 

 $k^*\leq k$ 

$$
E(RSS_k) = (n-k)\sigma^2
$$
and thus $C_p$ estimates 
$$
\begin{align*}
E(C_p) 
& = \frac{1}{n}\left( (n-k)\sigma^2 + 2k\sigma^2\right)\\ 
& = \frac{1}{n}\left( n\sigma^2 +  k\sigma^2\right)\\ 
& = \sigma^2 +  \frac{k}{n}\sigma^2
\end{align*}
$$   

how well a model fits the training data. One can show that RSS is monotonically decreasing in $p$ and correspondingly that $R^2$ is monotonically increasing in $p$. Thus, if we aim to select the model giving the smallest RSS or larges $R^2$, the model including all potential predictors would always be selected---even when many of the predictors are non-informative, nonsense predictors. 

The following information criteria include penalization terms for the number of parameters $p$ used in the model. Thus, we can use them to select models with different numbers of predictors $p$. 

Mellow's $C_p$:
$$
C_p=\frac{1}{n}\left(RSS + p\hat\sigma^2\right),
$$
where $\hat\sigma^2=\frac{1}{n-p_{\max}}\sum_{i=1}^n(y_i - \hat{y}_{i,p_{\max}})$ with $\hat{y}_{i,p_{\max}}$ being the fitted value from the linear regression with all $p_{\max}$ potential predictors included. 



Akaike information criterion (AIC) 

-->
</section>
<section id="ch.-6.1.1-best-subset-selection" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="ch.-6.1.1-best-subset-selection">(Ch. 6.1.1) Best Subset Selection</h3>
<p><strong>Algorithm 6.1: Best Subset Selection:</strong></p>
<ol type="1">
<li>Initialization: Let <span class="math inline">\(\mathcal{M}_0\)</span> denote the <em>null model</em> <span class="math inline">\(f(X)=\beta_0\)</span> containing no predictors, except the intercept. (This model predicts each observed outcome by the total sample mean.)</li>
<li>For <span class="math inline">\(k=1,2,\dots,p:\)</span>
<ol type="i">
<li>Fit all <span class="math inline">\(\binom{p}{k}\)</span> models that contain exactly <span class="math inline">\(k\)</span> predictors.</li>
<li>Pick the “best” among these <span class="math inline">\(\binom{p}{k}\)</span> models, and call it <span class="math inline">\(\widehat{\mathcal{M}}_k\)</span>. Here “best” is defined as having smallest <span class="math inline">\(\operatorname{RSS}_k\)</span> (or equivalently highest <span class="math inline">\(R^2.\)</span>)</li>
</ol></li>
<li>Select a single best model from <span class="math inline">\(\widehat{\mathcal{M}}_0,\dots,\widehat{\mathcal{M}}_p\)</span> using CV, Mellow’s <span class="math inline">\(C_p\)</span> (AIC), BIC, or <span class="math inline">\(\operatorname{adjusted } R^2.\)</span></li>
</ol>
<p><br></p>
<p>Step 2 of Algorithm 6.1 identifies the best model (on training data) for each subset size <span class="math inline">\(k\)</span>, and thus reduces the model selection problem from <span class="math inline">\(2^p\)</span> models to <span class="math inline">\(p+1\)</span> models.</p>
<p><a href="images/Fig_6_1.png"></a></p>
<p>Best subset selection (Algorithm 6.1) can be computationally expensive for largish <span class="math inline">\(p\)</span>.</p>
<table class="table">
<thead>
<tr class="header">
<th><span class="math inline">\(p\)</span></th>
<th><span class="math inline">\(2^p\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(10\)</span></td>
<td><span class="math inline">\(1024\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(20\)</span></td>
<td><span class="math inline">\(1048576\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(40\)</span></td>
<td><span class="math inline">\(1.1\cdot 10^{12}\)</span></td>
</tr>
</tbody>
</table>
<p><strong>Summary:</strong></p>
<ul>
<li><p>Best subset selection becomes computationally infeasible for values of <span class="math inline">\(p\)</span> greater than about <span class="math inline">\(40\)</span>, even with extremely fast modern computers.</p></li>
<li><p>Moreover, the larger the search space, the higher the chance of finding models that look good in the training data (Step 2), even tough they might not have any predictive power in test data.</p></li>
</ul>
</section>
<section id="ch.-6.1.2-stepwise-selection" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="ch.-6.1.2-stepwise-selection">(Ch. 6.1.2) Stepwise Selection</h3>
<section id="forward-stepwise-selection" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="forward-stepwise-selection">Forward Stepwise Selection</h4>
<p><strong>Algorithm 6.2: Forward Stepwise Selection:</strong></p>
<ol type="1">
<li>Initialization: Let <span class="math inline">\(\mathcal{M}_0\)</span> denote the <em>null model</em> <span class="math inline">\(f(X)=\beta_0\)</span> containing no predictors, except the intercept. (This model predicts each observed outcome by the total sample mean.)</li>
<li>For <span class="math inline">\(k=0,1,\dots,p-1:\)</span>
<ol type="i">
<li>Fit all <span class="math inline">\(p-k\)</span> models that augment the predictors in <span class="math inline">\(\widehat{\mathcal{M}}_k\)</span> with one additional predictor.</li>
<li>Pick the “best” among these <span class="math inline">\(p-k\)</span> models, and call it <span class="math inline">\(\widehat{\mathcal{M}}_{k+1}\)</span>. Here “best” is defined as having smallest <span class="math inline">\(\operatorname{RSS}_{k+1}\)</span> (or equivalently highest <span class="math inline">\(R^2.\)</span>)</li>
</ol></li>
<li>Select a single best model from <span class="math inline">\(\widehat{\mathcal{M}}_0,\dots,\widehat{\mathcal{M}}_p\)</span> using CV, Mellow’s <span class="math inline">\(C_p\)</span> (AIC), BIC, or <span class="math inline">\(\operatorname{adjusted } R^2.\)</span></li>
</ol>
<p><br></p>
<p>Unlike best subset selection, which involved fitting <span class="math inline">\(2^p\)</span> models, <strong>forward stepwise selection</strong> considers a much smaller set of models: It begins with fitting the null <span class="math inline">\((p=0)\)</span> model, and proceeds with fitting <span class="math inline">\(p-k\)</span> models in the <span class="math inline">\(k\)</span>th iteration, for <span class="math inline">\(k=1,\dots,p-1.\)</span> This amounts to a total of <span class="math display">\[
1+\sum_{k=0}^{p-1}(p-k) = 1 + p(p+1)/2
\]</span> models.</p>
<table class="table">
<thead>
<tr class="header">
<th><span class="math inline">\(p\)</span></th>
<th><span class="math inline">\(2^p\)</span></th>
<th><span class="math inline">\(1 + p(p+1)/2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(10\)</span></td>
<td><span class="math inline">\(1024\)</span></td>
<td><span class="math inline">\(56\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(20\)</span></td>
<td><span class="math inline">\(1048576\)</span></td>
<td><span class="math inline">\(211\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(40\)</span></td>
<td><span class="math inline">\(1.1\cdot 10^{12}\)</span></td>
<td><span class="math inline">\(821\)</span></td>
</tr>
</tbody>
</table>
<p>Forward stepwise selection is a guided search strategy, that tends to do well in practice. However, it is not guaranteed to find the best possible model out of all <span class="math inline">\(2^2p\)</span> models containing subsets of the <span class="math inline">\(p\)</span> predictors.</p>
<p><strong>Example:</strong> Consider the case of <span class="math inline">\(p=3\)</span> predictors <span class="math inline">\(X_1,\,X_2\)</span> and <span class="math inline">\(X_3.\)</span> Let the best one-predictor model contain <span class="math inline">\(X_1\)</span>, and let the best two-predictor model contain <span class="math inline">\(X_2\)</span> and <span class="math inline">\(X_3.\)</span> Then forward stepwise selection will fail to select the best two-predictor model.</p>
<p><img src="images/Tab_6_1.png" class="img-fluid"></p>
</section>
<section id="backward-stepwise-selection" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="backward-stepwise-selection">Backward Stepwise Selection</h4>
<p><strong>Algorithm 6.3: Backward Stepwise Selection:</strong></p>
<ol type="1">
<li>Initialization: Let <span class="math inline">\(\mathcal{M}_p\)</span> denote the <em>full model</em> which contains all <span class="math inline">\(p\)</span> predictors.</li>
<li>For <span class="math inline">\(k=p,p-1,\dots,1:\)</span>
<ol type="i">
<li>Fit all <span class="math inline">\(k\)</span> models that contain all but one of the predictors in <span class="math inline">\(\widehat{\mathcal{M}}_k,\)</span> for a total of <span class="math inline">\(k-1\)</span> predictors.</li>
<li>Pick the “best” among these <span class="math inline">\(k\)</span> models, and call it <span class="math inline">\(\widehat{\mathcal{M}}_{k-1}\)</span>. Here “best” is defined as having smallest <span class="math inline">\(\operatorname{RSS}_{k+1}\)</span> (or equivalently highest <span class="math inline">\(R^2.\)</span>)</li>
</ol></li>
<li>Select a single best model from <span class="math inline">\(\widehat{\mathcal{M}}_0,\dots,\widehat{\mathcal{M}}_p\)</span> using CV, Mellow’s <span class="math inline">\(C_p\)</span> (AIC), BIC, or <span class="math inline">\(\operatorname{adjusted } R^2.\)</span></li>
</ol>
<p>Like forward stepwise selection, the backward selection approach searches through only <span class="math inline">\(1 + p(p+1)/2\)</span> models, and thus can be applied when <span class="math inline">\(p\)</span> is too large to apply best subset selection.</p>
<p>Like forward stepwise selection, the backward selection approach is a guided search strategy, that tends to do well in practice. However, it is not guaranteed to find the best possible model out of all <span class="math inline">\(2^2p\)</span> models containing subsets of the <span class="math inline">\(p\)</span> predictors.</p>
<p>Backward selection requires that the sample size <span class="math inline">\(n\)</span> is larger than the number of predictors <span class="math inline">\(p\)</span> (so that the full model can be fit).</p>
</section>
<section id="hybrid-approaches" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="hybrid-approaches">Hybrid Approaches</h4>
<p>The above selection algorithms often give similar, but not identical models. The literature knows many alternative selection algorithms such as hybrid approaches in which, for instance, variables are added to the model sequentially, in analogy to forward selection; however, after adding each new variable, the method may also remove any variables that no longer provide an improvement in the model fit.</p>
</section>
</section>
</section>
<section id="ch.-6.2-shrinkage-methods" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="ch.-6.2-shrinkage-methods">(Ch. 6.2) Shrinkage Methods</h2>
<p>The discussed subset selection methods involve using least squares to fit the linear models. Alternatively, we can fit a model containing all <span class="math inline">\(p\)</span> predictors using a technique that constrains or regularizes the coefficient estimates by shrinking the coefficient estimates towards zero.</p>
<p>The two best-known techniques for shrinking the regression coefficients towards zero are</p>
<ol type="1">
<li>Ridge Regression and</li>
<li>Lasso</li>
</ol>
<section id="ch.-6.2.1-ridge-regression" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="ch.-6.2.1-ridge-regression">(Ch. 6.2.1) Ridge Regression</h3>
<p>Recall from Chapter 3 that the least squares fitting procedure estimates <span class="math inline">\(\beta_0, \beta_1, \dots, \beta_p\)</span> using parameter values that minimize the RSS criterion <span id="eq-LeastSqCrit"><span class="math display">\[
\operatorname{RSS}=\sum_{i=1}^n\left(y_i - \beta_0 - \sum_{j=1}^p\beta_jx_{ij}\right)^2.
\tag{6.3}\]</span></span></p>
<p>Ridge regression is very similar to least squares, except that the coefficients are estimated by minimizing a slightly different quantity. The ridge regression coefficient estimates <span class="math inline">\(\hat\beta^R\)</span> are the values that minimize <span id="eq-RidgeCrit"><span class="math display">\[
\begin{align*}
\underbrace{\sum_{i=1}^n\left(y_i - \beta_0 - \sum_{j=1}^p\beta_jx_{ij}\right)^2}_{=\operatorname{RSS}}+\lambda \sum_{j=1}^p\beta_j^2,
%= &amp;\operatorname{RSS} +\lambda \sum_{j=1}^p\beta_j^2,
\end{align*}
\tag{6.4}\]</span></span> where <span class="math inline">\(\lambda \sum_{j=1}^p\beta_j^2\)</span> is called <em>shrinkage penalty</em>, and where <span class="math inline">\(\lambda\)</span> is a <em>tuning parameter</em> that needs to be determined separately. <a href="#eq-RidgeCrit">Equation&nbsp;<span>6.4</span></a> trades of two different criteria:</p>
<ol type="1">
<li>By making RSS small, ridge regression tries to fit the data well.</li>
<li>By making <span class="math inline">\(\sum_{j=1}^p\beta_j^2=||(\beta_{1},\dots,\beta_{p})'||^2_2\)</span> small, ridge regression shrinks all coefficient estimates towards zero—except the intercept <span class="math inline">\(\beta_0.\)</span></li>
</ol>
<blockquote class="blockquote">
<p><span class="math inline">\(||\beta||_2 = \sqrt{\sum_{j=1}^p\beta_j^2}\)</span> denotes the <span class="math inline">\(\ell_2\)</span> (or Euclidean) norm of a <span class="math inline">\(p\)</span>-dimensional vector <span class="math inline">\(\beta.\)</span> If <span class="math inline">\(||\beta||_2\to 0\)</span> then all elements <span class="math inline">\(\beta_1,\dots,\beta_p\)</span> eventually approach <span class="math inline">\(0.\)</span></p>
</blockquote>
<p>The tuning parameter <span class="math inline">\(\lambda\)</span> controls the relative impact of these two terms on the regression coefficient estimates:</p>
<ul>
<li>When <span class="math inline">\(\lambda=0\)</span>, the penalty term has no effect, and ridge regression will produce the least squares estimates.</li>
<li>As <span class="math inline">\(\lambda\to\infty\)</span>, the impact of the shrinkage penalty grows, and the ridge regression coefficient estimates will approach zero.</li>
</ul>
<p>Ridge regression will produce a different set of coefficient estimates, <span class="math display">\[
\hat\beta_\lambda^R=(\hat\beta_{1,\lambda}^R,\dots,\hat\beta_{p,\lambda}^R)',
\]</span> for each value of <span class="math inline">\(\lambda.\)</span> Selecting a good value for <span class="math inline">\(\lambda\)</span> is critical and can be accomplished using, for instance, cross-validation.</p>
<section id="standardized-ridge-regression-coefficients" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="standardized-ridge-regression-coefficients">Standardized Ridge Regression Coefficients</h4>
<p>The RSS criterion of least squares (<a href="#eq-LeastSqCrit">Equation&nbsp;<span>6.3</span></a>) is <strong>scale equivariant</strong>. Scaling a predictor by a constant <span class="math inline">\(c\)</span> from <span class="math inline">\(x_{ij}\)</span> to <span class="math inline">\(x^S_{ij}=x_{ij}c\)</span> will simply rescale the corresponding least squares estimate from <span class="math inline">\(\hat\beta_j\)</span> to <span class="math inline">\(\hat\beta_j^S=\hat\beta_j/c\)</span> such that <span class="math display">\[
x_{ij}\hat\beta_j = x_{ij}^S\hat\beta_j^S,\quad i=1,\dots,n
\]</span> which leaves the fitted values unchanged, and thus the RSS value unaffected.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>n         <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>x         <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n =</span> n, <span class="at">mean =</span> <span class="dv">50000</span>, <span class="at">sd =</span> <span class="dv">10000</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>eps       <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n =</span> n, <span class="at">mean =</span> <span class="dv">0</span>,     <span class="at">sd =</span> <span class="dv">10000</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>y         <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">+</span> <span class="dv">5</span> <span class="sc">*</span> x <span class="sc">+</span> eps</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>lm_obj_1  <span class="ot">&lt;-</span> <span class="fu">lm</span>(y <span class="sc">~</span> x)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>RSS_1     <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">resid</span>(lm_obj_1)<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>c         <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">1000</span> <span class="co"># scaling factor </span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>x_S       <span class="ot">&lt;-</span> x <span class="sc">*</span> c</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>lm_obj_2  <span class="ot">&lt;-</span> <span class="fu">lm</span>(y <span class="sc">~</span> x_S)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>RSS_2     <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">resid</span>(lm_obj_2)<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="do">## comparing the estimates </span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="fu">coef</span>(lm_obj_1)[<span class="dv">2</span>] <span class="sc">/</span> c, </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coef</span>(lm_obj_2)[<span class="dv">2</span>]),</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="at">digits =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     x    x_S 
5031.3 5031.3 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="do">## comparing the RSS's:</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(RSS_1, RSS_2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 9853402653 9853402653</code></pre>
</div>
</div>
<p>By contrast, the ridge regression criterion in <a href="#eq-RidgeCrit">Equation&nbsp;<span>6.4</span></a> is <strong><em>not</em> scale invariant</strong> since scaling the predictors will lead (as seen above) to a rescaling of the coefficient estimates and thus affects the penalty term <span class="math inline">\(\lambda\sum_{j=1}^p\beta_j^2.\)</span></p>
<p>Thus, scaling one or more predictors will generally affect <em>all</em> ridge regression estimates <span class="math inline">\(\hat\beta_{0,\lambda}^R,\dots,\hat\beta_{p,\lambda}^R,\)</span> since typically the regressors are correlated with each other.</p>
<p>Therefore, it is best practice to apply ridge regression <strong>after standardizing the predictors</strong>, using the formula <span id="eq-Standardization"><span class="math display">\[
\tilde{x}_{ij}=\frac{x_{ij}}{\sqrt{\frac{1}{n}\sum_{i=1}^n(x_{ij}-\bar{x}_j)^2}}
\tag{6.5}\]</span></span> so that they are all on the same scale; i.e.&nbsp;all standardized predictors have a standard deviation of one.</p>
<p>After standardizing the predictors, the ridge regression coefficient estimates do not depend on the different scales on which the predictors were measured.</p>
<p>Ridge regression estimates based on standardized predictors are called <strong>standardized ridge regression coefficients</strong>. The absolute values of the standardized coefficients allow us to rank the effects of the predictors on the depend variable: the predictor corresponding to the largest (in absolute values) standardized coefficient has the largest effect on the dependent variable.</p>
<p>Figure 6.4 shows the standardized ridge regression coefficient estimates for the <code>Credit</code> dataset. Each curve corresponds to the ridge regression coefficient estimate for one of the ten variables, plotted as a function of <span class="math inline">\(\lambda\)</span>.</p>
<p><img src="images/Fig_6_4.png" class="img-fluid"></p>
<p>Interpretation of Figure 6.4:</p>
<ul>
<li>The case, where <span class="math inline">\(||\hat\beta^R_\lambda||_2/||\hat\beta||_2=1\)</span>, i.e.&nbsp;where <span class="math inline">\(\lambda\approx 0\)</span>, is equivalent to the least squares fit.</li>
<li>The case where <span class="math inline">\(||\hat\beta^R_\lambda||_2/||\hat\beta||_2=0\)</span>, i.e.&nbsp;where <span class="math inline">\(\lambda\)</span> is very large, corresponds to the case where <span class="math inline">\(\hat\beta^R_{\lambda 1}\approx\dots\approx \hat\beta^R_{\lambda p}\approx 0.\)</span></li>
</ul>
</section>
</section>
<section id="why-and-when-does-ridge-regression-improve-over-least-squares" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="why-and-when-does-ridge-regression-improve-over-least-squares">Why and When Does Ridge Regression Improve Over Least Squares?</h3>
<p>Ridge regression’s potential advantage over least squares is rooted in the bias-variance trade-off.</p>
<ul>
<li>A large value of <span class="math inline">\(\lambda\)</span> decreases the flexibility of the model, and thus decreases variance, but increases bias.</li>
<li>A small value of <span class="math inline">\(\lambda\)</span> increases the flexibility of the model, and thus decreases bias, but increases variance.</li>
</ul>
<blockquote class="blockquote">
<p>High variance means that a small change in the training data can cause a large change in the coefficient estimates</p>
</blockquote>
<blockquote class="blockquote">
<p>Large bias means that the coefficient estimates are <em>on average</em> not equal to the true coefficient values</p>
</blockquote>
<p>Figure 6.5 illustrates this, using a simulated data set containing <span class="math inline">\(p = 45\)</span> predictors and <span class="math inline">\(n = 50\)</span> observations. When the number of variables <span class="math inline">\(p\)</span> is almost as large as the number of observations <span class="math inline">\(n\)</span>, as in the example in Figure 6.5, the least squares estimates will be extremely variable.</p>
<p><img src="images/Fig_6_5.png" class="img-fluid"></p>
<p>In comparison to the least squares fit (<span class="math inline">\(\lambda\approx 0\)</span>, <span class="math inline">\(||\hat\beta^R_\lambda||_2/||\hat\beta||_2=1\)</span>), the ridge regression shows a lower test MSE for an appropriate choice of <span class="math inline">\(\lambda.\)</span></p>
<p>Generally, ridge regression outperforms least squares in situations where the least squares estimates have high variance—as in the example of Fig 6.5. In these high variance situations, ridge regression can trade off a small increase in bias for a large decrease in variance leading to an overall reduction in the test MSE.</p>
<p>If <span class="math inline">\(p &gt; n\)</span>, then the least squares estimates do not have a unique solution, but ridge regression estimates are well defined.</p>
<p>Moreover, ridge regression also has substantial computational advantages over best subset selection, which requires searching through <span class="math inline">\(2^p\)</span> fitted models. In contrast, ridge regression models only need to be fitted once for each candidate tuning parameter <span class="math inline">\(\lambda.\)</span></p>
</section>
</section>
<section id="ch.-6.2.2-the-lasso" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="ch.-6.2.2-the-lasso">(Ch. 6.2.2) The Lasso</h2>
<p>While ridge regression is able to show which predictors are of major vs.&nbsp;minor relevance for predicting the outcome, none of the predictors is actually removed from the model equation since none of the coefficients is exactly set to zero—unless in the limit <span class="math inline">\(\lambda = \infty,\)</span> but then coefficients are zero (no variable selection).</p>
<p>This may not be a problem with respect to prediction accuracy, but it can create a challenge in model interpretation—particularly in settings in which the number of variables <span class="math inline">\(p\)</span> is quite large.</p>
<p>For example, in the <code>Credit</code> data set, it appears that the most important variables are <code>income</code>, <code>limit</code>, <code>rating</code>, and <code>student</code>. So we might wish to build a model including just these predictors. However, ridge regression will always generate a model involving all ten predictors.</p>
<p>The <strong>lasso</strong> is a relatively recent alternative to ridge regression that overcomes this disadvantage. The lasso coefficients, <span class="math inline">\(\hat\beta_\lambda^L\)</span>, minimize <span id="eq-LassoCrit"><span class="math display">\[
\begin{align*}
\underbrace{\sum_{i=1}^n\left(y_i - \beta_0 - \sum_{j=1}^p\beta_jx_{ij}\right)^2}_{=\operatorname{RSS}}+\lambda \sum_{j=1}^p|\beta_j|.
%= &amp;\operatorname{RSS} +\lambda \sum_{j=1}^p\beta_j^2,
\end{align*}
\tag{6.6}\]</span></span></p>
<p>By contrast to the ridge regression criterion (<a href="#eq-RidgeCrit">Equation&nbsp;<span>6.4</span></a>), the lasso criterion uses an <span class="math inline">\(\ell_1\)</span> norm <span class="math display">\[
||(\beta_{1},\dots,\beta_p)'||_1 = \sum_{j=1}^p|\beta_j|
\]</span> as a shrinkage penalty. The <span class="math inline">\(\ell_1\)</span> penalty has the effect of forcing some of the coefficient estimates to be exactly equal to zero when the tuning parameter <span class="math inline">\(\lambda\)</span> is sufficiently large.</p>
<p>Lasso yields sparse models—that is, models that involve only a subset of the variables (see Figure 6.6). Sparse models are easier to interpret.</p>
<p><img src="images/Fig_6_6.png" class="img-fluid"></p>
<section id="comparing-lasso-ridge-regression-and-best-subset-selection" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="comparing-lasso-ridge-regression-and-best-subset-selection">Comparing Lasso, Ridge Regression and Best Subset Selection</h4>
<p>One can show that the lasso and ridge regression coefficient estimates solve constrained optimization (minimization) problems.</p>
<p>Lasso: <span id="eq-LassoCrit2"><span class="math display">\[
\min_{\beta}\left\{\sum_{i=1}^n\left(y_i - \beta_0 - \sum_{j=1}^p\beta_jx_{ij}\right)^2\right\}\;\text{s.t.}\; \sum_{j=1}^p|\beta_j|\leq s
\tag{6.7}\]</span></span></p>
<p>Ridge: <span id="eq-RidgeCrit2"><span class="math display">\[
\min_{\beta}\left\{\sum_{i=1}^n\left(y_i - \beta_0 - \sum_{j=1}^p\beta_jx_{ij}\right)^2\right\}\;\text{s.t.}\; \sum_{j=1}^p\beta_j^2\leq s
\tag{6.8}\]</span></span></p>
<p>That is, for every <span class="math inline">\(\lambda\)</span> in <a href="#eq-RidgeCrit">Equation&nbsp;<span>6.4</span></a> there is some <span class="math inline">\(s\)</span> such in <a href="#eq-RidgeCrit2">Equation&nbsp;<span>6.8</span></a> that will lead to the same ridge coefficient estimates, and for every <span class="math inline">\(\lambda\)</span> in <a href="#eq-LassoCrit">Equation&nbsp;<span>6.6</span></a> there is some <span class="math inline">\(s\)</span> such in <a href="#eq-LassoCrit2">Equation&nbsp;<span>6.7</span></a> that will lead to the same lasso coefficient estimates.</p>
<p>In the case of two <span class="math inline">\((p=2)\)</span> predictors, one can interpret <a href="#eq-LassoCrit2">Equation&nbsp;<span>6.7</span></a> and <a href="#eq-RidgeCrit2">Equation&nbsp;<span>6.8</span></a> graphically (see Figure 6.7).</p>
<ul>
<li><p>the lasso coefficient estimates have the smallest RSS out of all points <span class="math inline">\((\beta_1,\beta_2)\)</span> that lie within the <em>diamond</em> defined by <span class="math inline">\(|\beta_1|+|\beta_2|\leq s.\)</span></p></li>
<li><p>the ridge coefficient estimates have the smallest RSS out of all points <span class="math inline">\((\beta_1,\beta_2)\)</span> that lie within the <em>circle</em> defined by <span class="math inline">\(\beta_1^2+\beta_2^2\leq s.\)</span></p></li>
</ul>
<p><img src="images/Fig_6_7.png" class="img-fluid"></p>
<p>Interpretation of Figure 6.7:</p>
<ul>
<li><p>The tuning parameter <span class="math inline">\(s\)</span> acts like a budge constraint for how large the penalty term can be. This key idea also applies to cases <span class="math inline">\(p&gt;2,\)</span> although plotting then becomes difficult/infeasible.</p></li>
<li><p>Figure 6.7 shows why lasso is able to perform variable selection, by contrast to ridge regression. The ellipses show coefficient estimates leading to equal RSS values. While the <span class="math inline">\(\ell_1\)</span> geometry of lasso’s “budge constraint” allows to set a coefficient value to zero (here <span class="math inline">\(\beta_1\)</span>), the <span class="math inline">\(\ell_2\)</span> geometry of ridge regression’s budget constraint only allows to shrink a coefficient value <em>towards</em> zero.</p></li>
</ul>
</section>
<section id="connection-with-best-subset-selection" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="connection-with-best-subset-selection">Connection with Best Subset Selection</h4>
<p><a href="#eq-LassoCrit2">Equation&nbsp;<span>6.7</span></a> and <a href="#eq-RidgeCrit2">Equation&nbsp;<span>6.8</span></a> reveal a close connection between the lasso, ridge regression, and best subset selection. Consider the problem <span id="eq-BestSubSetCrit"><span class="math display">\[
\min_{\beta}\left\{\sum_{i=1}^n\left(y_i - \beta_0 - \sum_{j=1}^p\beta_jx_{ij}\right)^2\right\}\;\text{s.t.}\; \sum_{j=1}^pI(\beta_j\neq 0)\leq s,
\tag{6.9}\]</span></span> where <span class="math inline">\(I(\beta_j\neq 0)=1\)</span> if <span class="math inline">\(\beta_j\neq 0\)</span> and zero else.</p>
<p><a href="#eq-BestSubSetCrit">Equation&nbsp;<span>6.9</span></a> amounts to finding a set of at most <span class="math inline">\(s\)</span> many coefficient estimates such that RSS is as small as possible. The problem of <a href="#eq-BestSubSetCrit">Equation&nbsp;<span>6.9</span></a> is equivalent to Step 2 in Best Subset Selection (Algorithm 6.1) for a given number of predictors <span class="math inline">\(s\)</span> (or <span class="math inline">\(k\)</span> in the notation of Algorithm 6.1). The choice of <span class="math inline">\(s\)</span> (or equivalently <span class="math inline">\(\lambda\)</span>) is then critical and needs to be done using, for instance, cross-validation.</p>
<p>This insight allows us to interpret ridge regression and lasso (even more so) as computationally feasible versions of Best Subset Regression.</p>
</section>
<section id="comparing-the-lasso-and-ridge-regression" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="comparing-the-lasso-and-ridge-regression">Comparing the Lasso and Ridge Regression</h4>
<p>Figure 6.8 displays the variance, squared bias, and test MSE of the lasso applied to the same simulated data as in Figure 6.5; i.e.&nbsp;<span class="math inline">\(p=45\)</span> and <span class="math inline">\(n=50.\)</span> Thus, in the case, where many predictors have an effect on the response, ridge regression can perform better than lasso.</p>
<p><img src="images/Fig_6_8.png" class="img-fluid"></p>
<p>Figure 6.9 illustrates a similar situation, except that now the response is a function of only <span class="math inline">\(p=2\)</span> out of 45 predictors. Now the lasso tends to outperform ridge regression in terms of bias, variance, and MSE.</p>
<p><img src="images/Fig_6_9.png" class="img-fluid"></p>
<p>In general, one might expect the lasso to perform better in <strong>sparse models</strong>, i.e.&nbsp;in a setting where a relatively small number of predictors have substantial coefficients, and the remaining predictors have coefficients that are very small or equal zero. Ridge regression will perform better when the response is a function of many predictors.</p>
</section>
<section id="ch.-6.2.3-selecting-the-tuning-parameter" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="ch.-6.2.3-selecting-the-tuning-parameter">(Ch. 6.2.3) Selecting the Tuning Parameter</h3>
<p>Each value of the tuning parameters <span class="math inline">\(\lambda\)</span> in <a href="#eq-RidgeCrit">Equation&nbsp;<span>6.4</span></a> and <a href="#eq-LassoCrit">Equation&nbsp;<span>6.6</span></a> or of the tuning parameters <span class="math inline">\(s\)</span> in <a href="#eq-LassoCrit2">Equation&nbsp;<span>6.7</span></a> and <a href="#eq-RidgeCrit2">Equation&nbsp;<span>6.8</span></a> represent a new more or less flexible model—similarly to the tuning parameter <span class="math inline">\(k\)</span>, with <span class="math inline">\(k\leq p\)</span>, (i.e., number of predictors included) in Best Subset Selection. Thus, as in Best Subset Selection we need to be carful when comparing models of different size and flexibility.</p>
<p>Cross-validation provides a simple way to tackle this problem. We choose a grid of <span class="math inline">\(\lambda\)</span> values, and compute the coss-validation error for each value of <span class="math inline">\(\lambda\)</span>, as described in <a href="Ch5_ResamplingMethods.html"><span>Chapter&nbsp;5</span></a>.</p>
<p>We then select the tuning parameter value for which the cross-validation error is smallest. Finally, the model is re-fit using all of the available observations and the selected value of the tuning parameter.</p>
<p><img src="images/Fig_6_13.png" class="img-fluid"></p>
</section>
</section>
<section id="ch.-6.3-dimension-reduction-methods" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="ch.-6.3-dimension-reduction-methods">(Ch. 6.3) Dimension Reduction Methods</h2>
<p>The methods discussed so far in this chapter are all defined using the total set of predictors <span class="math inline">\(X_1,X_2,\dots,X_p\)</span> in <a href="#eq-modelLarge">Equation&nbsp;<span>6.1</span></a>. We now explore a class of approaches that transform the set of <span class="math inline">\(p\)</span> predictors to a reduced set of <span class="math inline">\(M\leq p\)</span> <em>transformed</em> variables, and then fit a least squares model using only the <span class="math inline">\(M\)</span> transformed variables as predictors.</p>
<p>Let <span class="math inline">\(Z_1,\dots,Z_M\)</span> represent <span class="math inline">\(M\leq p\)</span> <em>linear combinations</em> of our original <span class="math inline">\(p\)</span> predictors, i.e. <span id="eq-TransfX1"><span class="math display">\[
Z_m = \sum_{j=1}^p\phi_{jm}X_{j},\quad\text{for}\quad m=1,\dots,M.
\tag{6.10}\]</span></span></p>
<p>Given the new predictors <span class="math inline">\(Z_1,\dots,Z_M\)</span>, we can fit the linear regression model <span id="eq-LinMod_Trans_M"><span class="math display">\[
y_i = \theta_0 +  \sum_{m=1}^M\theta_m z_{im} + \epsilon_i,\quad i=1,\dots,n,
\tag{6.11}\]</span></span> where <span class="math inline">\(z_{im}\)</span>, <span class="math inline">\(i=1,\dots,n\)</span>, are observed measurements from <span class="math inline">\(Z_m,\)</span> based on observations <span class="math inline">\(x_{ij}\)</span> from <span class="math inline">\(X_j\)</span>, and where <span class="math inline">\(\theta_0,\dots,\theta_M\)</span> are the (unknown) regression coefficients that we estimate using least squares.</p>
<p>If the constants <span class="math inline">\(\phi_{jm}\)</span> in <a href="#eq-TransfX1">Equation&nbsp;<span>6.10</span></a> are chosen wisely, then such dimension reduction (from <span class="math inline">\(p\)</span> to <span class="math inline">\(M\)</span>) approaches can outperform (lower test MSE) least squares regression.</p>
<p>Notice that the linear combination of the <span class="math inline">\(M\)</span> transformed predictors, <span class="math inline">\(z_{i1},\dots,z_{iM}\)</span>, in <a href="#eq-LinMod_Trans_M">Equation&nbsp;<span>6.11</span></a> can be rewritten as a linear combination of the <span class="math inline">\(p\)</span> original predictors, <span class="math inline">\(x_{i1},\dots,x_{ip}\)</span>: <span class="math display">\[
\begin{align*}
\sum_{m=1}^M\theta_m z_{im}
&amp;= \sum_{m=1}^M\theta_m \overbrace{\left(\sum_{j=1}^p\phi_{jm}x_{ij}\right)}^{z_{im}}\\
&amp;= \sum_{j=1}^p\underbrace{\left(\sum_{m=1}^M\theta_m \phi_{jm}\right)}_{=\beta^M_j}x_{ij}.
\end{align*}
\]</span> Hereby, <span id="eq-RegulBeta_M"><span class="math display">\[
\beta^M_j = \sum_{m=1}^M\theta_m \phi_{jm}
\tag{6.12}\]</span></span> serves as a certain regularized version of the coefficients <span class="math inline">\(\beta_j\)</span> in the original linear model <a href="#eq-modelLarge">Equation&nbsp;<span>6.1</span></a>.</p>
<ul>
<li>If <span class="math inline">\(M=p\)</span> (no dimension reduction), and if all <span class="math inline">\(M\)</span> many <span class="math inline">\((z_{1m},\dots,z_{nm})',\)</span> <span class="math inline">\(m=1,\dots,M,\)</span> vectors are linearly independent from each other (i.e.&nbsp;no redundant vectors), then <a href="#eq-RegulBeta_M">Equation&nbsp;<span>6.12</span></a> poses <em>no constraints</em> and <span class="math inline">\(\beta_j^M=\beta_j.\)</span></li>
<li>If <span class="math inline">\(M&lt;p\)</span> (dimension reduction), <a href="#eq-RegulBeta_M">Equation&nbsp;<span>6.12</span></a> serves to constrain the estimated <span class="math inline">\(\beta_j\)</span> coefficients <span class="math inline">\((\beta_j^M\neq \beta_j).\)</span></li>
</ul>
<p>All dimension reduction methods work in two steps.</p>
<ol type="1">
<li>The transformed predictors <span class="math inline">\(Z_1,Z_2,\dots,Z_M\)</span> are obtained.</li>
<li>The model is fit using these <span class="math inline">\(M\leq p\)</span> predictors.</li>
</ol>
<p>However, the choice of <span class="math inline">\(Z_1,Z_2,\dots,Z_M,\)</span> or equivalently the selection of the <span class="math inline">\(\phi_m\)</span>’s, can be achieved in different ways.</p>
<p>The best known dimension reduction approach is <strong>principal components regression</strong>.</p>
<!-- * partial least squares regression () -->
<section id="ch.-6.3.1-principal-components-regression" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="ch.-6.3.1-principal-components-regression">(Ch. 6.3.1) Principal Components Regression</h3>
<p>Principal components regression regression uses <strong>principal components</strong> to derive new (low dimensional) predictors. Thus, in a first step we need to discuss principal components analysis (PCA) to construct principal components.</p>
<section id="principal-component-analysis-pca" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="principal-component-analysis-pca">Principal Component Analysis (PCA)</h4>
<p>Reading: Chapter 12.2.1 of our textbook.</p>
<p>Principal components analysis is a popular approach for deriving a low-dimensional <span class="math inline">\((M&lt;p)\)</span> set of features <span class="math inline">\(Z_1,Z_2,\dots,Z_M\)</span> from a large set of variables <span class="math inline">\(X_1,X_2,\dots,X_p.\)</span></p>
<p>The first principal component (or better principal component score) of a set of variables <span class="math inline">\(X_1,X_2,\dots,X_p\)</span> is the normalized linear combination <span class="math display">\[
Z_1 = \phi_{11}X_{1} + \dots + \phi_{p1}X_{p},
\]</span> that maximizes the variance of <span class="math inline">\(Z_1.\)</span> By <em>normalized</em>, we mean that the <span class="math inline">\(\ell_2\)</span> norm of <span class="math inline">\(\phi_1=(\phi_{11},\dots,\phi_{p1})'\)</span> must equal one, i.e. <span class="math display">\[
\sum_{j=1}^p\phi_{j1}^2=||\phi_1||_2^2=1;
\]</span> otherwise we could make the variance of <span class="math inline">\(Z_1\)</span> arbitrarily large by simply by choosing <span class="math inline">\(\phi_1\)</span> such that <span class="math inline">\(||\phi_1||_2^2\)</span> is large.</p>
<p>The vector <span class="math inline">\(\phi_1=(\phi_{11},\dots,\phi_{p1})'\)</span> is called the principal component <strong>loadings</strong> vector. An in absolute values large loading parameter <span class="math inline">\(\phi_{1j}\)</span> means that the <span class="math inline">\(j\)</span>th predictor <span class="math inline">\(X_j\)</span> contributes much to the first principal component score <span class="math inline">\(Z_1.\)</span></p>
<p>To estimate the coefficients <span class="math inline">\(\phi_1=(\phi_{11},\dots,\phi_{p1})',\)</span> we need observed measurements of the features <span class="math inline">\(X_1,\dots,X_p.\)</span> We collect these observed measurements in a <span class="math inline">\(n\times p\)</span> dimensional data matrix <span class="math inline">\(\mathbf{X},\)</span> such that <span class="math display">\[
\mathbf{X} = \left[
    \begin{matrix}
    x_{11}&amp;x_{12}&amp;\dots&amp;x_{1p}\\
    \vdots&amp;\vdots&amp;\vdots&amp;\vdots\\
    x_{n1}&amp;x_{n2}&amp;\dots&amp;x_{np}\\
    \end{matrix}
\right],
\]</span> where the columns in <span class="math inline">\(\mathbf{X}\)</span> are centered. That is, the <span class="math inline">\(j\)</span>th data column in <span class="math inline">\(X\)</span> consists of centered data points<br>
<span class="math display">\[x_{ij}=x^{orig}_{ij}-\bar{x}^{orig}_j
\quad\text{with}\quad
\bar{x}^{orig}_j = \frac{1}{n}\sum_{i=1}^nx_{ij}^{orig}
\]</span> such that the sample mean of each column in <span class="math inline">\(X\)</span> is zero, i.e. <span class="math display">\[
\bar{x}_{j} = \frac{1}{n}\sum_{i=1}^nx_{ij}=0
\]</span> for each <span class="math inline">\(j=1,\dots,p.\)</span></p>
<p>With centered observations <span class="math inline">\(x_{ij}\)</span>, the observed linear combinations <span class="math display">\[
z_{i1} = \phi_{11}x_{i1} + \dots + \phi_{p1}x_{ip},
\]</span> become centered too, since <span class="math display">\[
\begin{align*}
\bar{z}_1
&amp;=\frac{1}{n}\sum_{i=1}^nz_{i1} \\
&amp;=\frac{1}{n}\sum_{i=1}^n\left(\phi_{11}x_{i1} + \dots + \phi_{p1}x_{ip}\right)\\
&amp;= \phi_{11} \frac{1}{n}\sum_{i=1}^n x_{i1} + \dots + \phi_{p1} \frac{1}{n}\sum_{i=1}^nx_{ip}\\
&amp; = \phi_{11}\bar{x}_{1} + \dots + \phi_{p1}\bar{x}_{p} = 0.
\end{align*}
\]</span></p>
<p>Therefore, the formula for the sample variance of <span class="math inline">\(z_{i1}\)</span>, <span class="math inline">\(i=1,\dots,n\)</span>, simplifies as following: <span id="eq-SampleVarSimple"><span class="math display">\[
\frac{1}{n}\sum_{i=1}^n\left(z_{i1}-\bar{z}_1\right)^2=\frac{1}{n}\sum_{i=1}^nz_{i1}^2
\tag{6.13}\]</span></span></p>
<p>To determine the <strong>first principal component scores</strong> <span class="math display">\[
z_{11},\dots,z_{n1},
\]</span> we need to find that loading vector <span class="math inline">\(\phi_1=(\phi_{11},\dots,\phi_{p1})'\)</span> that maximizes the sample variance <span class="math display">\[
\frac{1}{n}\sum_{i=1}^nz_{i1}^2 = \frac{1}{n}\sum_{i=1}^n\left(\phi_{11}x_{i1} + \dots + \phi_{p1}x_{ip}\right)^2
\]</span> subject to the side constraint that <span class="math inline">\(||\phi_1||_2^2=1.\)</span> In other words, the first principal component loading vector <span class="math inline">\(\phi_1=(\phi_{11},\dots,\phi_{p1})'\)</span> is determined as the solution of the optimization problem <span class="math display">\[
\max_{\phi_{11},\dots,\phi_{p1}}\underbrace{\left\{\frac{1}{n}\sum_{i=1}^n\left(\sum_{j=1}^p\phi_{j1}x_{ij}\right)^2\right\}}_{=\frac{1}{n}\sum_{i=1}^nz_{i1}^2}\quad\text{s.t.}\quad\sum_{j=1}^p\phi_{j1}^2=1,
\]</span> where <span class="math inline">\(\frac{1}{n}\sum_{i=1}^nz_{i1}^2\)</span> equals the sample variance of <span class="math inline">\(z_{11},\dots,z_{n1}\)</span> (see <a href="#eq-SampleVarSimple">Equation&nbsp;<span>6.13</span></a>).</p>
<p>There is a nice geometric interpretation for the first principal component (likewise for the further principal components). The first loading vector <span class="math display">\[
\phi_1=(\phi_{11},\dots,\phi_{p1})'
\]</span> defines a direction vector in the feature space along which the data points vary the most. If we project each of the <span class="math inline">\(n\)</span> many <span class="math inline">\(p\)</span>-dimensional data points <span class="math display">\[
\begin{align*}
x_1 &amp;=(x_{11},\dots,x_{1p})'\\
    &amp;\; \vdots \\
x_n &amp;=(x_{n1},\dots,x_{np})'
\end{align*}
\]</span> onto the direction vector <span class="math inline">\(\phi_1=(\phi_{11},\dots,\phi_{p1})'\)</span>, the projected values are the <strong>principal component scores</strong> <span class="math inline">\(z_{11},\dots,z_{n1}\)</span> themselves, i.e <span class="math display">\[
\begin{align*}
z_{11} &amp; = \phi_1'x_1 = \sum_{j=1}^p \phi_{j1}x_{1j}\\
&amp;\;\;\;\vdots \\
z_{n1} &amp; = \phi_1'x_n = \sum_{j=1}^p \phi_{j1}x_{nj}.
\end{align*}
\]</span></p>
<p>The case <span class="math inline">\(p=2\)</span> is simple to visualize. Figure 6.14 displays the direction of the first principal component loading vector <span class="math inline">\(\phi_1\)</span> (green solid line) on an advertising data set. <img src="images/Fig_6_14.png" class="img-fluid"></p>
<p>The left panel in Figure 6.15 displays the projection of the <span class="math inline">\(i\)</span>th, <span class="math inline">\(i=1,\dots,n,\)</span> data vectors <span class="math inline">\(x_i=(x_{i1},x_{i2})'\)</span> (purple circles 🟣) onto the first loading vector <span class="math inline">\(\phi_1=(\phi_{11},\phi_{21})'\)</span> leading to the <span class="math inline">\(i\)</span>th principal component score <span class="math inline">\(z_{i1},\)</span> <span class="math inline">\(i=1,\dots,n,\)</span> (black crosses <span class="math inline">\(\mathbf{\times}\)</span>.</p>
<p><img src="images/Fig_6_15.png" class="img-fluid"></p>
</section>
<section id="higher-order-principal-components" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="higher-order-principal-components">Higher order principal components</h4>
<p>After the first principal component of the features has been determined, we can find the second principal component. The second principal component is the linear combination of <span class="math inline">\(X_1,X_2,\dots,X_p\)</span> that has maximal variance out of all linear combinations that are <strong>uncorrelated</strong> with <span class="math inline">\(Z_1.\)</span></p>
<p>Thus, the second principal component scores <span class="math inline">\(z_{12},\dots,z_{np}\)</span> take the form <span class="math display">\[
z_{i2} = \phi_2'x_i = \sum_{j=1}^p \phi_{j2}x_{ij},
\]</span> where <span class="math inline">\(\phi_2=(\phi_{12},\dots,\phi_{p2})'\)</span> is the second principal component loading vector with <span class="math inline">\(||\phi_2||_2^2=1.\)</span></p>
<p>Constraining <span class="math inline">\(Z_2\)</span> to be uncorrelated with <span class="math inline">\(Z_1\)</span> is equivalent to constraining <span class="math inline">\(\phi_2\)</span> to be orthogonal to <span class="math inline">\(\phi_1\)</span>, i.e.&nbsp;the inner product of <span class="math inline">\(\phi_1\)</span> and <span class="math inline">\(\phi_2\)</span> must be zero, <span class="math display">\[
\phi_2'\phi_1=\sum_{j=1}^p\phi_{j2}\phi_{j1}=0.
\]</span> Therefore, the loading vector <span class="math inline">\(\phi_2=(\phi_{12},\dots,\phi_{p2})'\)</span> is determined by the solution of <span class="math display">\[
\begin{align*}
\max_{\phi_{12},\dots,\phi_{p2}}&amp;\underbrace{\left\{\frac{1}{n}\sum_{i=1}^n\left(\sum_{j=1}^p\phi_{j2}x_{ij}\right)^2\right\}}_{=\frac{1}{n}\sum_{i=1}^nz_{i2}^2}\\
\text{such that}&amp; \quad \sum_{j=1}^p\phi_{j2}^2=1\quad\\
\text{and}&amp; \quad \sum_{j=1}^p\phi_{j1}\phi_{j2}=0.
\end{align*}
\]</span> Correspondingly, the <span class="math inline">\(m\)</span>th <span class="math inline">\((m=1,\dots,M)\)</span> loading vector <span class="math inline">\(\phi_m=(\phi_{1m},\dots,\phi_{pm})'\)</span> is determined by the solution of <span class="math display">\[
\begin{align*}
\max_{\phi_{1m},\dots,\phi_{pm}}&amp;\underbrace{\left\{\frac{1}{n}\sum_{i=1}^n\left(\sum_{j=1}^p\phi_{jm}x_{ij}\right)^2\right\}}_{=\frac{1}{n}\sum_{i=1}^nz_{im}^2}\\
\text{such that}&amp;\quad\sum_{j=1}^p\phi_{jm}^2=1\quad\\
\text{and}&amp;\quad \sum_{j=1}^p\phi_{j\ell}\phi_{jm}=0\quad\text{for all}\quad 0\leq \ell&lt;m,
\end{align*}
\]</span> with <span class="math inline">\(\phi_0=(\phi_{10},\dots,\phi_{p0})'=(0,\dots,0)'.\)</span></p>
<p>Again, the case <span class="math inline">\(p=2\)</span> is simple to visualize. If <span class="math inline">\(p=2\)</span> there are only <span class="math inline">\(M=2\)</span> principal components. As shown in Figure 6.14, the second principal components loading vector <span class="math inline">\(\phi_2\)</span> (blue dashed line) is <strong>orthogonal</strong> to the first loading vector <span class="math inline">\(\phi_1\)</span> (green solid line). Thus when rotating the coordinate system such that the direction of the first loading vector becomes the x-axis, then the direction of the second loading vector becomes the the orthogonal y-axis (see right panel of Figure 6.15).</p>
</section>
</section>
<section id="the-principal-components-regression-approach" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-principal-components-regression-approach">The Principal Components Regression Approach</h3>
<p>The <em>principal components regression</em> (PCR) approach fits the model in <a href="#eq-LinMod_Trans_M">Equation&nbsp;<span>6.11</span></a> which we repeat here for convenience: <span class="math display">\[
y_i = \theta_0 +  \sum_{m=1}^M\theta_m z_{im} + \epsilon_i,
\]</span> where <span class="math inline">\(z_{1m},\dots,z_{nm}\)</span> are the <span class="math inline">\(m\)</span>th principal component scores, and where the number of principal components <span class="math inline">\(M\)</span> acts as a tuning parameter.</p>
<p>The key idea is that often a small number <span class="math inline">\(M\ll p\)</span> of principal components suffice to explain most of the variability in the data <span class="math inline">\(\mathbf{X}.\)</span> Therefore, often a relatively low number of principal components <span class="math inline">\(M\ll p\)</span> suffices to achieve very good predictions (low test MSE).</p>
<p>Generally, fitting a least squares model to <span class="math inline">\(z_{i1},\dots,z_{iM},\)</span> <span class="math inline">\(i=1,\dots,n,\)</span> leads to better results than fitting a least squares model to <span class="math inline">\(x_{i1},\dots,x_{ip},\)</span> particularly when <span class="math inline">\(p\approx n,\)</span> since typically most of the information in the data <span class="math inline">\(\mathbf{X}\)</span> that relates to the response is contained in <span class="math inline">\(z_{i1},\dots,z_{iM},\)</span> <span class="math inline">\(i=1,\dots,n,\)</span> and by estimating only <span class="math inline">\(M\ll p\)</span> coefficients we can mitigate overfitting (high variance).</p>
<p>Figure 6.18 displays the PCR fits on the simulated data sets from Figures 6.8 and 6.9.</p>
<blockquote class="blockquote">
<p>Recall that both data sets were generated using <span class="math inline">\(n = 50\)</span> observations and <span class="math inline">\(p = 45\)</span> predictors. However, while the response in the first data set was a function of all the <span class="math inline">\(p=45\)</span> predictors (Figure 6.8), the response in the second data set was generated using only <span class="math inline">\(p=2\)</span> of the predictors (Figure 6.9).</p>
</blockquote>
<p><img src="images/Fig_6_18.png" class="img-fluid"></p>
<p>The curves in Figure 6.18 are plotted as a function of <span class="math inline">\(M,\)</span> the number of principal components used as predictors in the regression model.</p>
<ul>
<li>For <span class="math inline">\(M = p\)</span>, PCR is equivalent to a classic least squares fit using all of the original predictors</li>
<li>large <span class="math inline">\(M\)</span> values lead to flexible models with low bias, but large variance</li>
<li>small <span class="math inline">\(M\)</span> values lead to inflexible models with large bias, but low variance</li>
</ul>
<p>The latter two points lead to the typical U-shape of the test MSE.</p>
<p>Figure 6.18 indicates that PCR based on an appropriate choice of <span class="math inline">\(M\)</span> can substantially reduce the test MSE in comparison to classic least squares regression. In PCR, the number of principal components, <span class="math inline">\(M,\)</span> is typically chosen by cross-validation.</p>
<p><strong>Standardize the predictor variables.</strong> When performing PCR, it is generally a good idea to <strong>standardize</strong> each predictor, using <a href="#eq-Standardization">Equation&nbsp;<span>6.5</span></a>, prior to generating the principal components. Standardization ensures that all variables are on the same scale. In the absence of standardization, the high-variance predictors will tend to play a larger role in the principal components obtained, and thus the scale on which the variables are measured will ultimately have an effect on the final PCR model.</p>
</section>
</section>
<section id="r-lab-linear-model-selection-and-regularization" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="r-lab-linear-model-selection-and-regularization"><span class="header-section-number">6.1</span> <code>R</code>-Lab: Linear Model Selection and Regularization</h2>
<section id="subset-selection-methods" class="level3" data-number="6.1.1">
<h3 data-number="6.1.1" class="anchored" data-anchor-id="subset-selection-methods"><span class="header-section-number">6.1.1</span> Subset Selection Methods</h3>
<section id="best-subset-selection" class="level4" data-number="6.1.1.1">
<h4 data-number="6.1.1.1" class="anchored" data-anchor-id="best-subset-selection"><span class="header-section-number">6.1.1.1</span> Best Subset Selection</h4>
<p>Here we apply the best subset selection approach to the <code>Hitters</code> data. We wish to predict a baseball player’s <code>Salary</code> on the basis of various statistics associated with performance in the previous year.</p>
<p>First of all, we note that the <code>Salary</code> variable is missing for some of the players. The <code>is.na()</code> function can be used to identify the missing observations. It returns a vector of the same length as the input vector, with a <code>TRUE</code> for any elements that are missing, and a <code>FALSE</code> for non-missing elements. The <code>sum()</code> function can then be used to count all of the missing elements.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ISLR2) <span class="co"># load library 'ISLR2' (contains the data)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(Hitters) <span class="co"># check variable names of the Hitters data set </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "AtBat"     "Hits"      "HmRun"     "Runs"      "RBI"       "Walks"    
 [7] "Years"     "CAtBat"    "CHits"     "CHmRun"    "CRuns"     "CRBI"     
[13] "CWalks"    "League"    "Division"  "PutOuts"   "Assists"   "Errors"   
[19] "Salary"    "NewLeague"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(Hitters)   <span class="co"># check sample size n and number of predictors p</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 322  20</code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(<span class="fu">is.na</span>(Hitters<span class="sc">$</span>Salary)) <span class="co"># number of missing Salary observations</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 59</code></pre>
</div>
</div>
<p>Hence we see that <code>Salary</code> is missing for <span class="math inline">\(59\)</span> players. The <code>na.omit()</code> function removes all of the rows that have missing values in any variable.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>Hitters <span class="ot">&lt;-</span> <span class="fu">na.omit</span>(Hitters) <span class="co"># remove all rows containing missing data points </span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(Hitters)                <span class="co"># check sample size n and number of predictors p</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 263  20</code></pre>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(<span class="fu">is.na</span>(Hitters))         <span class="co"># no missing values anymore </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0</code></pre>
</div>
</div>
<p>The <code>regsubsets()</code> function (part of the <code>leaps</code> library) performs best subset selection by identifying the best model that contains a given number of predictors, where <em>best</em> is quantified using RSS. The syntax is the same as for <code>lm()</code>. The <code>summary()</code> command outputs the best set of variables for each model size.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(leaps)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>regfit_full <span class="ot">&lt;-</span> <span class="fu">regsubsets</span>(Salary <span class="sc">~</span> ., </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">nvmax  =</span> <span class="dv">8</span>,           <span class="co"># largest number of predictors</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                          <span class="at">nbest  =</span> <span class="dv">1</span>,           <span class="co"># number of subsets of each size to record</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>                          <span class="at">method =</span> <span class="st">"exhaustive"</span>,<span class="co"># Best Subset Selection</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>                          <span class="at">data   =</span> Hitters)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(regfit_full)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Subset selection object
Call: regsubsets.formula(Salary ~ ., nvmax = 8, nbest = 1, method = "exhaustive", 
    data = Hitters)
19 Variables  (and intercept)
           Forced in Forced out
AtBat          FALSE      FALSE
Hits           FALSE      FALSE
HmRun          FALSE      FALSE
Runs           FALSE      FALSE
RBI            FALSE      FALSE
Walks          FALSE      FALSE
Years          FALSE      FALSE
CAtBat         FALSE      FALSE
CHits          FALSE      FALSE
CHmRun         FALSE      FALSE
CRuns          FALSE      FALSE
CRBI           FALSE      FALSE
CWalks         FALSE      FALSE
LeagueN        FALSE      FALSE
DivisionW      FALSE      FALSE
PutOuts        FALSE      FALSE
Assists        FALSE      FALSE
Errors         FALSE      FALSE
NewLeagueN     FALSE      FALSE
1 subsets of each size up to 8
Selection Algorithm: exhaustive
         AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI
1  ( 1 ) " "   " "  " "   " "  " " " "   " "   " "    " "   " "    " "   "*" 
2  ( 1 ) " "   "*"  " "   " "  " " " "   " "   " "    " "   " "    " "   "*" 
3  ( 1 ) " "   "*"  " "   " "  " " " "   " "   " "    " "   " "    " "   "*" 
4  ( 1 ) " "   "*"  " "   " "  " " " "   " "   " "    " "   " "    " "   "*" 
5  ( 1 ) "*"   "*"  " "   " "  " " " "   " "   " "    " "   " "    " "   "*" 
6  ( 1 ) "*"   "*"  " "   " "  " " "*"   " "   " "    " "   " "    " "   "*" 
7  ( 1 ) " "   "*"  " "   " "  " " "*"   " "   "*"    "*"   "*"    " "   " " 
8  ( 1 ) "*"   "*"  " "   " "  " " "*"   " "   " "    " "   "*"    "*"   " " 
         CWalks LeagueN DivisionW PutOuts Assists Errors NewLeagueN
1  ( 1 ) " "    " "     " "       " "     " "     " "    " "       
2  ( 1 ) " "    " "     " "       " "     " "     " "    " "       
3  ( 1 ) " "    " "     " "       "*"     " "     " "    " "       
4  ( 1 ) " "    " "     "*"       "*"     " "     " "    " "       
5  ( 1 ) " "    " "     "*"       "*"     " "     " "    " "       
6  ( 1 ) " "    " "     "*"       "*"     " "     " "    " "       
7  ( 1 ) " "    " "     "*"       "*"     " "     " "    " "       
8  ( 1 ) "*"    " "     "*"       "*"     " "     " "    " "       </code></pre>
</div>
</div>
<p>An asterisk indicates that a given variable is included in the corresponding model. For instance, this output indicates that the best two-variable model contains only <code>Hits</code> and <code>CRBI</code>. By default, <code>regsubsets()</code> only reports results up to the best eight-variable model. But the <code>nvmax</code> option can be used in order to return as many variables as are desired. Next, we fit up to a 19-variable model.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>regfit_full <span class="ot">&lt;-</span> <span class="fu">regsubsets</span>(Salary <span class="sc">~</span> ., </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                          <span class="at">nvmax  =</span> <span class="dv">19</span>,          <span class="co"># largest number of predictors</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">nbest  =</span> <span class="dv">1</span>,           <span class="co"># number of subsets of each size to record</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>                          <span class="at">method =</span> <span class="st">"exhaustive"</span>,<span class="co"># Best Subset Selection</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>                          <span class="at">data   =</span> Hitters)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>reg_summary <span class="ot">&lt;-</span> <span class="fu">summary</span>(regfit_full)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <code>summary()</code> function also returns <span class="math inline">\(R^2\)</span>, RSS, adjusted <span class="math inline">\(R^2\)</span>, <span class="math inline">\(C_p\)</span>, and BIC. We can examine these to try to select the <em>best overall model</em>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(reg_summary)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "which"  "rsq"    "rss"    "adjr2"  "cp"     "bic"    "outmat" "obj"   </code></pre>
</div>
</div>
<p>For instance, we see that the <span class="math inline">\(R^2\)</span> statistic increases from <span class="math inline">\(32\,\%\)</span>, when only one variable is included in the model, to almost <span class="math inline">\(55\,\%\)</span>, when all variables are included. That is, as expected, the <span class="math inline">\(R^2\)</span> statistic increases monotonically as more variables are included. (Equivalently, RSS decreases monotonically as more variables are includes.)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>reg_summary<span class="sc">$</span>rsq</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 0.3214501 0.4252237 0.4514294 0.4754067 0.4908036 0.5087146 0.5141227
 [8] 0.5285569 0.5346124 0.5404950 0.5426153 0.5436302 0.5444570 0.5452164
[15] 0.5454692 0.5457656 0.5459518 0.5460945 0.5461159</code></pre>
</div>
</div>
<p>Plotting RSS, adjusted <span class="math inline">\(R^2\)</span>, <span class="math inline">\(C_p\)</span>, and BIC for all of the models at once will help us decide which model to select. Note the <code>type = "l"</code> option tells <code>R</code> to connect the plotted points with lines.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(reg_summary<span class="sc">$</span>rss, <span class="at">xlab =</span> <span class="st">"Number of Variables"</span>,</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">ylab =</span> <span class="st">"RSS"</span>, <span class="at">type =</span> <span class="st">"l"</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(reg_summary<span class="sc">$</span>adjr2, <span class="at">xlab =</span> <span class="st">"Number of Variables"</span>,</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">ylab =</span> <span class="st">"Adjusted RSq"</span>, <span class="at">type =</span> <span class="st">"l"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk7-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The <code>points()</code> command works like the <code>plot()</code> command, except that it puts points on a plot that has already been created, instead of creating a new plot. The <code>which.max()</code> function can be used to identify the location of the maximum point of a vector. We will now plot a red dot to indicate the model with the largest adjusted <span class="math inline">\(R^2\)</span> statistic.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">which.max</span>(reg_summary<span class="sc">$</span>adjr2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 11</code></pre>
</div>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(reg_summary<span class="sc">$</span>adjr2, <span class="at">xlab =</span> <span class="st">"Number of Variables"</span>,</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">ylab =</span> <span class="st">"Adjusted RSq"</span>, <span class="at">type =</span> <span class="st">"l"</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(<span class="dv">11</span>, reg_summary<span class="sc">$</span>adjr2[<span class="dv">11</span>], <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">cex =</span> <span class="dv">2</span>, </span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">pch =</span> <span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk8-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In a similar fashion we can plot the <span class="math inline">\(C_p\)</span> and BIC statistics, and indicate the models with the smallest statistic using <code>which.min()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(reg_summary<span class="sc">$</span>cp, <span class="at">xlab =</span> <span class="st">"Number of Variables"</span>,</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">ylab =</span> <span class="st">"Cp"</span>, <span class="at">type =</span> <span class="st">"l"</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">which.min</span>(reg_summary<span class="sc">$</span>cp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 10</code></pre>
</div>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(<span class="dv">10</span>, reg_summary<span class="sc">$</span>cp[<span class="dv">10</span>], <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">cex =</span> <span class="dv">2</span>,</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">pch =</span> <span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk9-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">which.min</span>(reg_summary<span class="sc">$</span>bic)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 6</code></pre>
</div>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(reg_summary<span class="sc">$</span>bic, <span class="at">xlab =</span> <span class="st">"Number of Variables"</span>,</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">ylab =</span> <span class="st">"BIC"</span>, <span class="at">type =</span> <span class="st">"l"</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(<span class="dv">6</span>, reg_summary<span class="sc">$</span>bic[<span class="dv">6</span>], <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">cex =</span> <span class="dv">2</span>,</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">pch =</span> <span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk9-2.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The <code>regsubsets()</code> function has a built-in <code>plot()</code> command which can be used to display the selected variables for the best model with a given number of predictors, ranked according to the BIC, <span class="math inline">\(C_p\)</span>, adjusted <span class="math inline">\(R^2\)</span>, or AIC. To find out more about this function, type <code>?plot.regsubsets</code>. The grey-shading represents a color-code for the selected information criterion.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(regfit_full, <span class="at">scale =</span> <span class="st">"r2"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk10-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(regfit_full, <span class="at">scale =</span> <span class="st">"adjr2"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk10-2.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(regfit_full, <span class="at">scale =</span> <span class="st">"Cp"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk10-3.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(regfit_full, <span class="at">scale =</span> <span class="st">"bic"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk10-4.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The top row of each plot contains a black square for each variable selected according to the optimal model associated with that statistic. For instance, we see that several models share a BIC close to <span class="math inline">\(-150\)</span>. However, the model with the lowest BIC is the six-variable model that contains only <code>AtBat</code>, <code>Hits</code>, <code>Walks</code>, <code>CRBI</code>, <code>DivisionW</code>, and <code>PutOuts</code>.</p>
<p>We can use the <code>coef()</code> function to see the coefficient estimates associated with this model. To find the correct <code>id</code> we need to find the number of the model shown in the output of <code>summary(regfit_full)</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(regfit_full, <span class="at">id =</span> <span class="dv">6</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> (Intercept)        AtBat         Hits        Walks         CRBI    DivisionW 
  91.5117981   -1.8685892    7.6043976    3.6976468    0.6430169 -122.9515338 
     PutOuts 
   0.2643076 </code></pre>
</div>
</div>
</section>
<section id="forward-and-backward-stepwise-selection" class="level4" data-number="6.1.1.2">
<h4 data-number="6.1.1.2" class="anchored" data-anchor-id="forward-and-backward-stepwise-selection"><span class="header-section-number">6.1.1.2</span> Forward and Backward Stepwise Selection</h4>
<p>We can also use the <code>regsubsets()</code> function to perform forward stepwise or backward stepwise selection, using the argument <code>method = "forward"</code> or <code>method = "backward"</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>regfit.fwd <span class="ot">&lt;-</span> <span class="fu">regsubsets</span>(Salary <span class="sc">~</span> ., <span class="at">data =</span> Hitters,</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">nvmax =</span> <span class="dv">19</span>, <span class="at">method =</span> <span class="st">"forward"</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(regfit.fwd)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Subset selection object
Call: regsubsets.formula(Salary ~ ., data = Hitters, nvmax = 19, method = "forward")
19 Variables  (and intercept)
           Forced in Forced out
AtBat          FALSE      FALSE
Hits           FALSE      FALSE
HmRun          FALSE      FALSE
Runs           FALSE      FALSE
RBI            FALSE      FALSE
Walks          FALSE      FALSE
Years          FALSE      FALSE
CAtBat         FALSE      FALSE
CHits          FALSE      FALSE
CHmRun         FALSE      FALSE
CRuns          FALSE      FALSE
CRBI           FALSE      FALSE
CWalks         FALSE      FALSE
LeagueN        FALSE      FALSE
DivisionW      FALSE      FALSE
PutOuts        FALSE      FALSE
Assists        FALSE      FALSE
Errors         FALSE      FALSE
NewLeagueN     FALSE      FALSE
1 subsets of each size up to 19
Selection Algorithm: forward
          AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI
1  ( 1 )  " "   " "  " "   " "  " " " "   " "   " "    " "   " "    " "   "*" 
2  ( 1 )  " "   "*"  " "   " "  " " " "   " "   " "    " "   " "    " "   "*" 
3  ( 1 )  " "   "*"  " "   " "  " " " "   " "   " "    " "   " "    " "   "*" 
4  ( 1 )  " "   "*"  " "   " "  " " " "   " "   " "    " "   " "    " "   "*" 
5  ( 1 )  "*"   "*"  " "   " "  " " " "   " "   " "    " "   " "    " "   "*" 
6  ( 1 )  "*"   "*"  " "   " "  " " "*"   " "   " "    " "   " "    " "   "*" 
7  ( 1 )  "*"   "*"  " "   " "  " " "*"   " "   " "    " "   " "    " "   "*" 
8  ( 1 )  "*"   "*"  " "   " "  " " "*"   " "   " "    " "   " "    "*"   "*" 
9  ( 1 )  "*"   "*"  " "   " "  " " "*"   " "   "*"    " "   " "    "*"   "*" 
10  ( 1 ) "*"   "*"  " "   " "  " " "*"   " "   "*"    " "   " "    "*"   "*" 
11  ( 1 ) "*"   "*"  " "   " "  " " "*"   " "   "*"    " "   " "    "*"   "*" 
12  ( 1 ) "*"   "*"  " "   "*"  " " "*"   " "   "*"    " "   " "    "*"   "*" 
13  ( 1 ) "*"   "*"  " "   "*"  " " "*"   " "   "*"    " "   " "    "*"   "*" 
14  ( 1 ) "*"   "*"  "*"   "*"  " " "*"   " "   "*"    " "   " "    "*"   "*" 
15  ( 1 ) "*"   "*"  "*"   "*"  " " "*"   " "   "*"    "*"   " "    "*"   "*" 
16  ( 1 ) "*"   "*"  "*"   "*"  "*" "*"   " "   "*"    "*"   " "    "*"   "*" 
17  ( 1 ) "*"   "*"  "*"   "*"  "*" "*"   " "   "*"    "*"   " "    "*"   "*" 
18  ( 1 ) "*"   "*"  "*"   "*"  "*" "*"   "*"   "*"    "*"   " "    "*"   "*" 
19  ( 1 ) "*"   "*"  "*"   "*"  "*" "*"   "*"   "*"    "*"   "*"    "*"   "*" 
          CWalks LeagueN DivisionW PutOuts Assists Errors NewLeagueN
1  ( 1 )  " "    " "     " "       " "     " "     " "    " "       
2  ( 1 )  " "    " "     " "       " "     " "     " "    " "       
3  ( 1 )  " "    " "     " "       "*"     " "     " "    " "       
4  ( 1 )  " "    " "     "*"       "*"     " "     " "    " "       
5  ( 1 )  " "    " "     "*"       "*"     " "     " "    " "       
6  ( 1 )  " "    " "     "*"       "*"     " "     " "    " "       
7  ( 1 )  "*"    " "     "*"       "*"     " "     " "    " "       
8  ( 1 )  "*"    " "     "*"       "*"     " "     " "    " "       
9  ( 1 )  "*"    " "     "*"       "*"     " "     " "    " "       
10  ( 1 ) "*"    " "     "*"       "*"     "*"     " "    " "       
11  ( 1 ) "*"    "*"     "*"       "*"     "*"     " "    " "       
12  ( 1 ) "*"    "*"     "*"       "*"     "*"     " "    " "       
13  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    " "       
14  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    " "       
15  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    " "       
16  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    " "       
17  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    "*"       
18  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    "*"       
19  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    "*"       </code></pre>
</div>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>regfit.bwd <span class="ot">&lt;-</span> <span class="fu">regsubsets</span>(Salary <span class="sc">~</span> ., <span class="at">data =</span> Hitters,</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">nvmax =</span> <span class="dv">19</span>, <span class="at">method =</span> <span class="st">"backward"</span>)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(regfit.bwd)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Subset selection object
Call: regsubsets.formula(Salary ~ ., data = Hitters, nvmax = 19, method = "backward")
19 Variables  (and intercept)
           Forced in Forced out
AtBat          FALSE      FALSE
Hits           FALSE      FALSE
HmRun          FALSE      FALSE
Runs           FALSE      FALSE
RBI            FALSE      FALSE
Walks          FALSE      FALSE
Years          FALSE      FALSE
CAtBat         FALSE      FALSE
CHits          FALSE      FALSE
CHmRun         FALSE      FALSE
CRuns          FALSE      FALSE
CRBI           FALSE      FALSE
CWalks         FALSE      FALSE
LeagueN        FALSE      FALSE
DivisionW      FALSE      FALSE
PutOuts        FALSE      FALSE
Assists        FALSE      FALSE
Errors         FALSE      FALSE
NewLeagueN     FALSE      FALSE
1 subsets of each size up to 19
Selection Algorithm: backward
          AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI
1  ( 1 )  " "   " "  " "   " "  " " " "   " "   " "    " "   " "    "*"   " " 
2  ( 1 )  " "   "*"  " "   " "  " " " "   " "   " "    " "   " "    "*"   " " 
3  ( 1 )  " "   "*"  " "   " "  " " " "   " "   " "    " "   " "    "*"   " " 
4  ( 1 )  "*"   "*"  " "   " "  " " " "   " "   " "    " "   " "    "*"   " " 
5  ( 1 )  "*"   "*"  " "   " "  " " "*"   " "   " "    " "   " "    "*"   " " 
6  ( 1 )  "*"   "*"  " "   " "  " " "*"   " "   " "    " "   " "    "*"   " " 
7  ( 1 )  "*"   "*"  " "   " "  " " "*"   " "   " "    " "   " "    "*"   " " 
8  ( 1 )  "*"   "*"  " "   " "  " " "*"   " "   " "    " "   " "    "*"   "*" 
9  ( 1 )  "*"   "*"  " "   " "  " " "*"   " "   "*"    " "   " "    "*"   "*" 
10  ( 1 ) "*"   "*"  " "   " "  " " "*"   " "   "*"    " "   " "    "*"   "*" 
11  ( 1 ) "*"   "*"  " "   " "  " " "*"   " "   "*"    " "   " "    "*"   "*" 
12  ( 1 ) "*"   "*"  " "   "*"  " " "*"   " "   "*"    " "   " "    "*"   "*" 
13  ( 1 ) "*"   "*"  " "   "*"  " " "*"   " "   "*"    " "   " "    "*"   "*" 
14  ( 1 ) "*"   "*"  "*"   "*"  " " "*"   " "   "*"    " "   " "    "*"   "*" 
15  ( 1 ) "*"   "*"  "*"   "*"  " " "*"   " "   "*"    "*"   " "    "*"   "*" 
16  ( 1 ) "*"   "*"  "*"   "*"  "*" "*"   " "   "*"    "*"   " "    "*"   "*" 
17  ( 1 ) "*"   "*"  "*"   "*"  "*" "*"   " "   "*"    "*"   " "    "*"   "*" 
18  ( 1 ) "*"   "*"  "*"   "*"  "*" "*"   "*"   "*"    "*"   " "    "*"   "*" 
19  ( 1 ) "*"   "*"  "*"   "*"  "*" "*"   "*"   "*"    "*"   "*"    "*"   "*" 
          CWalks LeagueN DivisionW PutOuts Assists Errors NewLeagueN
1  ( 1 )  " "    " "     " "       " "     " "     " "    " "       
2  ( 1 )  " "    " "     " "       " "     " "     " "    " "       
3  ( 1 )  " "    " "     " "       "*"     " "     " "    " "       
4  ( 1 )  " "    " "     " "       "*"     " "     " "    " "       
5  ( 1 )  " "    " "     " "       "*"     " "     " "    " "       
6  ( 1 )  " "    " "     "*"       "*"     " "     " "    " "       
7  ( 1 )  "*"    " "     "*"       "*"     " "     " "    " "       
8  ( 1 )  "*"    " "     "*"       "*"     " "     " "    " "       
9  ( 1 )  "*"    " "     "*"       "*"     " "     " "    " "       
10  ( 1 ) "*"    " "     "*"       "*"     "*"     " "    " "       
11  ( 1 ) "*"    "*"     "*"       "*"     "*"     " "    " "       
12  ( 1 ) "*"    "*"     "*"       "*"     "*"     " "    " "       
13  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    " "       
14  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    " "       
15  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    " "       
16  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    " "       
17  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    "*"       
18  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    "*"       
19  ( 1 ) "*"    "*"     "*"       "*"     "*"     "*"    "*"       </code></pre>
</div>
</div>
<p>For instance, we see that using forward stepwise selection, the best one-variable model contains only <code>CRBI</code>, and the best two-variable model additionally includes <code>Hits</code>. For this data, the best one-variable through six-variable models are each identical for best subset and forward selection. However, the best seven-variable models identified by forward stepwise selection, backward stepwise selection, and best subset selection are different.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(regfit_full, <span class="at">id =</span> <span class="dv">7</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> (Intercept)         Hits        Walks       CAtBat        CHits       CHmRun 
  79.4509472    1.2833513    3.2274264   -0.3752350    1.4957073    1.4420538 
   DivisionW      PutOuts 
-129.9866432    0.2366813 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(regfit.fwd,  <span class="at">id =</span> <span class="dv">7</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> (Intercept)        AtBat         Hits        Walks         CRBI       CWalks 
 109.7873062   -1.9588851    7.4498772    4.9131401    0.8537622   -0.3053070 
   DivisionW      PutOuts 
-127.1223928    0.2533404 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(regfit.bwd,  <span class="at">id =</span> <span class="dv">7</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> (Intercept)        AtBat         Hits        Walks        CRuns       CWalks 
 105.6487488   -1.9762838    6.7574914    6.0558691    1.1293095   -0.7163346 
   DivisionW      PutOuts 
-116.1692169    0.3028847 </code></pre>
</div>
</div>
</section>
<section id="choosing-among-models-using-the-validation-set-approach-and-cross-validation" class="level4" data-number="6.1.1.3">
<h4 data-number="6.1.1.3" class="anchored" data-anchor-id="choosing-among-models-using-the-validation-set-approach-and-cross-validation"><span class="header-section-number">6.1.1.3</span> Choosing Among Models Using the Validation-Set Approach and cross-validation</h4>
<p>We just saw that it is possible to choose among a set of models of different sizes using <span class="math inline">\(C_p\)</span>, BIC, and adjusted <span class="math inline">\(R^2\)</span>. We will now consider how to do this using the validation set and cross-validation approaches.</p>
<p>In order for these approaches to yield accurate estimates of the test error, we must use <em>only the training observations</em> to perform all aspects of model-fitting—including variable selection. Therefore, the determination of which model of a given size is best must be made using <em>only the training observations</em>. This point is subtle but important. If the full data set is used to perform the best subset selection step, the validation set errors and cross-validation errors that we obtain will not be accurate estimates of the test error.</p>
<p>In order to use the validation set approach, we begin by splitting the observations into a training set and a test set. We do this by creating a random vector, <code>train</code>, of elements equal to <code>TRUE</code> if the corresponding observation is in the training set, and <code>FALSE</code> otherwise. The vector <code>test</code> has a <code>TRUE</code> if the observation is in the test set, and a <code>FALSE</code> otherwise. Note the <code>!</code> in the command to create <code>test</code> causes <code>TRUE</code>s to be switched to <code>FALSE</code>s and vice versa. We also set a random seed so that the user will obtain the same training set/test set split.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>train <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="cn">TRUE</span>, <span class="cn">FALSE</span>), <span class="fu">nrow</span>(Hitters),</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>test <span class="ot">&lt;-</span> (<span class="sc">!</span>train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, we apply <code>regsubsets()</code> to the training set in order to perform best subset selection.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>regfit.best <span class="ot">&lt;-</span> <span class="fu">regsubsets</span>(Salary <span class="sc">~</span> .,</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> Hitters[train, ], <span class="at">nvmax =</span> <span class="dv">19</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Notice that we subset the <code>Hitters</code> data frame directly in the call in order to access only the training subset of the data, using the expression <code>Hitters[train, ]</code>. We now compute the validation set error for the best model of each model size. We first make a model matrix from the test data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>test.mat <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(Salary <span class="sc">~</span> ., <span class="at">data =</span> Hitters[test, ])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <code>model.matrix()</code> function is used in many regression packages for building an <span class="math inline">\(X\)</span> matrix from data. Now we run a loop, and for each size <code>i</code>, we extract the coefficients from <code>regfit.best</code> for the best model of that size, multiply them into the appropriate columns of the test model matrix to form the predictions, and compute the test MSE.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>val.errors <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="dv">19</span>)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">19</span>){</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a> coefi         <span class="ot">&lt;-</span> <span class="fu">coef</span>(regfit.best, <span class="at">id =</span> i)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a> pred          <span class="ot">&lt;-</span> test.mat[, <span class="fu">names</span>(coefi)] <span class="sc">%*%</span> coefi</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a> val.errors[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>((Hitters<span class="sc">$</span>Salary[test] <span class="sc">-</span> pred)<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We find that the best model is the one that contains seven variables.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>val.errors</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 164377.3 144405.5 152175.7 145198.4 137902.1 139175.7 126849.0 136191.4
 [9] 132889.6 135434.9 136963.3 140694.9 140690.9 141951.2 141508.2 142164.4
[17] 141767.4 142339.6 142238.2</code></pre>
</div>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">which.min</span>(val.errors)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 7</code></pre>
</div>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(regfit.best, <span class="dv">7</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> (Intercept)        AtBat         Hits        Walks        CRuns       CWalks 
  67.1085369   -2.1462987    7.0149547    8.0716640    1.2425113   -0.8337844 
   DivisionW      PutOuts 
-118.4364998    0.2526925 </code></pre>
</div>
</div>
<p>This was a little tedious, partly because there is no <code>predict()</code> method for <code>regsubsets()</code>. Since we will be using this function again, we can capture our steps above and write our own predict method.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a> predict.regsubsets <span class="ot">&lt;-</span> <span class="cf">function</span>(object, newdata, id, ...) {</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  form <span class="ot">&lt;-</span> <span class="fu">as.formula</span>(object<span class="sc">$</span>call[[<span class="dv">2</span>]])</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  mat <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(form, newdata)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>  coefi <span class="ot">&lt;-</span> <span class="fu">coef</span>(object, <span class="at">id =</span> id)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  xvars <span class="ot">&lt;-</span> <span class="fu">names</span>(coefi)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>  mat[, xvars] <span class="sc">%*%</span> coefi</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a> }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Our function pretty much mimics what we did above. The only complex part is how we extracted the formula used in the call to <code>regsubsets()</code>. We demonstrate how we use this function below, when we do cross-validation.</p>
<p>Finally, we perform best subset selection on the full data set, and select the best seven-variable model. It is important that we make use of the full data set in order to obtain more accurate coefficient estimates. Note that we perform best subset selection on the full data set and select the best seven-variable model, rather than simply using the variables that were obtained from the training set, because the best seven-variable model on the full data set may differ from the corresponding model on the training set.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>regfit.best <span class="ot">&lt;-</span> <span class="fu">regsubsets</span>(Salary <span class="sc">~</span> ., <span class="at">data =</span> Hitters,</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">nvmax =</span> <span class="dv">19</span>)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(regfit.best, <span class="dv">7</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> (Intercept)         Hits        Walks       CAtBat        CHits       CHmRun 
  79.4509472    1.2833513    3.2274264   -0.3752350    1.4957073    1.4420538 
   DivisionW      PutOuts 
-129.9866432    0.2366813 </code></pre>
</div>
</div>
<p>In fact, we see that the best seven-variable model on the full data set has a different set of variables than the best seven-variable model on the training set.</p>
<p>We now try to choose among the models of different sizes using cross-validation. This approach is somewhat involved, as we must perform best subset selection <em>within each of the <span class="math inline">\(k\)</span> training sets</em>. Despite this, we see that with its clever subsetting syntax, <code>R</code> makes this job quite easy. First, we create a vector that allocates each observation to one of <span class="math inline">\(k=10\)</span> folds, and we create a matrix in which we will store the results.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(Hitters)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>folds <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>k, <span class="at">length =</span> n))</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>cv.errors <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, k, <span class="dv">19</span>,</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">dimnames =</span> <span class="fu">list</span>(<span class="cn">NULL</span>, <span class="fu">paste</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">19</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we write a for loop that performs cross-validation. In the <span class="math inline">\(j\)</span>th fold, the elements of <code>folds</code> that equal <code>j</code> are in the test set, and the remainder are in the training set. We make our predictions for each model size (using our new <code>predict()</code> method), compute the test errors on the appropriate subset, and store them in the appropriate slot in the matrix <code>cv.errors</code>. Note that in the following code <code>R</code> will automatically use our <code>predict.regsubsets()</code> function when we call <code>predict()</code> because the <code>best.fit</code> object has class <code>regsubsets</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>k) {</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  best.fit <span class="ot">&lt;-</span> <span class="fu">regsubsets</span>(Salary <span class="sc">~</span> .,</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>       <span class="at">data =</span> Hitters[folds <span class="sc">!=</span> j, ],</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>       <span class="at">nvmax =</span> <span class="dv">19</span>)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">19</span>) {</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(best.fit, Hitters[folds <span class="sc">==</span> j, ], <span class="at">id =</span> i)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    cv.errors[j, i] <span class="ot">&lt;-</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>         <span class="fu">mean</span>((Hitters<span class="sc">$</span>Salary[folds <span class="sc">==</span> j] <span class="sc">-</span> pred)<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a> }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This has given us a <span class="math inline">\(10 \times 19\)</span> matrix, of which the <span class="math inline">\((j,i)\)</span>th element corresponds to the test MSE for the <span class="math inline">\(j\)</span>th cross-validation fold for the best <span class="math inline">\(i\)</span>-variable model. We use the <code>apply()</code> function to average over the columns of this matrix in order to obtain a vector for which the <span class="math inline">\(i\)</span>th element is the cross-validation error for the <span class="math inline">\(i\)</span>-variable model.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>mean.cv.errors <span class="ot">&lt;-</span> <span class="fu">apply</span>(cv.errors, <span class="dv">2</span>, mean)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>mean.cv.errors</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       1        2        3        4        5        6        7        8 
143439.8 126817.0 134214.2 131782.9 130765.6 120382.9 121443.1 114363.7 
       9       10       11       12       13       14       15       16 
115163.1 109366.0 112738.5 113616.5 115557.6 115853.3 115630.6 116050.0 
      17       18       19 
116117.0 116419.3 116299.1 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(mean.cv.errors, <span class="at">type =</span> <span class="st">"b"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk23-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>We see that cross-validation selects a 10-variable model. We now perform best subset selection on the full data set in order to obtain the 10-variable model.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>reg.best <span class="ot">&lt;-</span> <span class="fu">regsubsets</span>(Salary <span class="sc">~</span> ., <span class="at">data =</span> Hitters,</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">nvmax =</span> <span class="dv">19</span>)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(reg.best, <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> (Intercept)        AtBat         Hits        Walks       CAtBat        CRuns 
 162.5354420   -2.1686501    6.9180175    5.7732246   -0.1300798    1.4082490 
        CRBI       CWalks    DivisionW      PutOuts      Assists 
   0.7743122   -0.8308264 -112.3800575    0.2973726    0.2831680 </code></pre>
</div>
</div>
</section>
</section>
<section id="ridge-regression-and-the-lasso" class="level3" data-number="6.1.2">
<h3 data-number="6.1.2" class="anchored" data-anchor-id="ridge-regression-and-the-lasso"><span class="header-section-number">6.1.2</span> Ridge Regression and the Lasso</h3>
<p>We will use the <code>glmnet</code> package in order to perform ridge regression and the lasso. The main function in this package is <code>glmnet()</code>, which can be used to fit ridge regression models, lasso models, and more. This function has slightly different syntax from other model-fitting functions that we have encountered thus far in this book. In particular, we must pass in an <code>x</code> matrix as well as a <code>y</code> vector, and we do not use the {} syntax. We will now perform ridge regression and the lasso in order to predict <code>Salary</code> on the <code>Hitters</code> data. Before proceeding ensure that the missing values have been removed from the data, as described in Section 6.5.1.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(Salary <span class="sc">~</span> ., Hitters)[, <span class="sc">-</span><span class="dv">1</span>]</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> Hitters<span class="sc">$</span>Salary</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <code>model.matrix()</code> function is particularly useful for creating <code>x</code>; not only does it produce a matrix corresponding to the <span class="math inline">\(19\)</span> predictors but it also automatically transforms any qualitative variables into dummy variables. The latter property is important because <code>glmnet()</code> can only take numerical, quantitative inputs.</p>
<section id="ridge-regression" class="level4" data-number="6.1.2.1">
<h4 data-number="6.1.2.1" class="anchored" data-anchor-id="ridge-regression"><span class="header-section-number">6.1.2.1</span> Ridge Regression</h4>
<p>The <code>glmnet()</code> function has an <code>alpha</code> argument that determines what type of model is fit. If <code>alpha=0</code> then a ridge regression model is fit, and if <code>alpha=1</code> then a lasso model is fit. We first fit a ridge regression model.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(glmnet)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: Matrix</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loaded glmnet 4.1-4</code></pre>
</div>
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>grid <span class="ot">&lt;-</span> <span class="dv">10</span><span class="sc">^</span><span class="fu">seq</span>(<span class="dv">10</span>, <span class="sc">-</span><span class="dv">2</span>, <span class="at">length =</span> <span class="dv">100</span>)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>ridge.mod <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(x, y, <span class="at">alpha =</span> <span class="dv">0</span>, <span class="at">lambda =</span> grid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>By default the <code>glmnet()</code> function performs ridge regression for an automatically selected range of <span class="math inline">\(\lambda\)</span> values. However, here we have chosen to implement the function over a grid of values ranging from <span class="math inline">\(\lambda=10^{10}\)</span> to <span class="math inline">\(\lambda=10^{-2}\)</span>, essentially covering the full range of scenarios from the null model containing only the intercept, to the least squares fit. As we will see, we can also compute model fits for a particular value of <span class="math inline">\(\lambda\)</span> that is not one of the original <code>grid</code> values. Note that by default, the <code>glmnet()</code> function standardizes the variables so that they are on the same scale. To turn off this default setting, use the argument <code>standardize = FALSE</code>.</p>
<p>Associated with each value of <span class="math inline">\(\lambda\)</span> is a vector of ridge regression coefficients, stored in a matrix that can be accessed by <code>coef()</code>. In this case, it is a <span class="math inline">\(20 \times 100\)</span> matrix, with <span class="math inline">\(20\)</span> rows (one for each predictor, plus an intercept) and <span class="math inline">\(100\)</span> columns (one for each value of <span class="math inline">\(\lambda\)</span>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(<span class="fu">coef</span>(ridge.mod))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  20 100</code></pre>
</div>
</div>
<p>We expect the coefficient estimates to be much smaller, in terms of <span class="math inline">\(\ell_2\)</span> norm, when a large value of <span class="math inline">\(\lambda\)</span> is used, as compared to when a small value of <span class="math inline">\(\lambda\)</span> is used. These are the coefficients when <span class="math inline">\(\lambda=11{,}498\)</span>, along with their <span class="math inline">\(\ell_2\)</span> norm:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>ridge.mod<span class="sc">$</span>lambda[<span class="dv">50</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 11497.57</code></pre>
</div>
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(ridge.mod)[, <span class="dv">50</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept)         AtBat          Hits         HmRun          Runs 
407.356050200   0.036957182   0.138180344   0.524629976   0.230701523 
          RBI         Walks         Years        CAtBat         CHits 
  0.239841459   0.289618741   1.107702929   0.003131815   0.011653637 
       CHmRun         CRuns          CRBI        CWalks       LeagueN 
  0.087545670   0.023379882   0.024138320   0.025015421   0.085028114 
    DivisionW       PutOuts       Assists        Errors    NewLeagueN 
 -6.215440973   0.016482577   0.002612988  -0.020502690   0.301433531 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span>(<span class="fu">sum</span>(<span class="fu">coef</span>(ridge.mod)[<span class="sc">-</span><span class="dv">1</span>, <span class="dv">50</span>]<span class="sc">^</span><span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 6.360612</code></pre>
</div>
</div>
<p>In contrast, here are the coefficients when <span class="math inline">\(\lambda=705\)</span>, along with their <span class="math inline">\(\ell_2\)</span> norm. Note the much larger <span class="math inline">\(\ell_2\)</span> norm of the coefficients associated with this smaller value of <span class="math inline">\(\lambda\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>ridge.mod<span class="sc">$</span>lambda[<span class="dv">60</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 705.4802</code></pre>
</div>
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(ridge.mod)[, <span class="dv">60</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> (Intercept)        AtBat         Hits        HmRun         Runs          RBI 
 54.32519950   0.11211115   0.65622409   1.17980910   0.93769713   0.84718546 
       Walks        Years       CAtBat        CHits       CHmRun        CRuns 
  1.31987948   2.59640425   0.01083413   0.04674557   0.33777318   0.09355528 
        CRBI       CWalks      LeagueN    DivisionW      PutOuts      Assists 
  0.09780402   0.07189612  13.68370191 -54.65877750   0.11852289   0.01606037 
      Errors   NewLeagueN 
 -0.70358655   8.61181213 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span>(<span class="fu">sum</span>(<span class="fu">coef</span>(ridge.mod)[<span class="sc">-</span><span class="dv">1</span>, <span class="dv">60</span>]<span class="sc">^</span><span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 57.11001</code></pre>
</div>
</div>
<p>We can use the <code>predict()</code> function for a number of purposes. For instance, we can obtain the ridge regression coefficients for a new value of <span class="math inline">\(\lambda\)</span>, say <span class="math inline">\(50\)</span>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="fu">predict</span>(ridge.mod, <span class="at">s =</span> <span class="dv">50</span>, <span class="at">type =</span> <span class="st">"coefficients"</span>)[<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept)         AtBat          Hits         HmRun          Runs 
 4.876610e+01 -3.580999e-01  1.969359e+00 -1.278248e+00  1.145892e+00 
          RBI         Walks         Years        CAtBat         CHits 
 8.038292e-01  2.716186e+00 -6.218319e+00  5.447837e-03  1.064895e-01 
       CHmRun         CRuns          CRBI        CWalks       LeagueN 
 6.244860e-01  2.214985e-01  2.186914e-01 -1.500245e-01  4.592589e+01 
    DivisionW       PutOuts       Assists        Errors    NewLeagueN 
-1.182011e+02  2.502322e-01  1.215665e-01 -3.278600e+00 -9.496680e+00 </code></pre>
</div>
</div>
<p>We now split the samples into a training set and a test set in order to estimate the test error of ridge regression and the lasso. There are two common ways to randomly split a data set. The first is to produce a random vector of <code>TRUE</code>, <code>FALSE</code> elements and select the observations corresponding to <code>TRUE</code> for the training data. The second is to randomly choose a subset of numbers between <span class="math inline">\(1\)</span> and <span class="math inline">\(n\)</span>; these can then be used as the indices for the training observations. The two approaches work equally well. We used the former method in Section 6.5.1. Here we demonstrate the latter approach.</p>
<p>We first set a random seed so that the results obtained will be reproducible.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>train <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(x), <span class="fu">nrow</span>(x) <span class="sc">/</span> <span class="dv">2</span>)</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>test <span class="ot">&lt;-</span> (<span class="sc">-</span>train)</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>y.test <span class="ot">&lt;-</span> y[test]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next we fit a ridge regression model on the training set, and evaluate its MSE on the test set, using <span class="math inline">\(\lambda=4\)</span>. Note the use of the <code>predict()</code> function again. This time we get predictions for a test set, by replacing <code>type="coefficients"</code> with the <code>newx</code> argument.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>ridge.mod <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(x[train, ], y[train], <span class="at">alpha =</span> <span class="dv">0</span>,</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">lambda =</span> grid, <span class="at">thresh =</span> <span class="fl">1e-12</span>)</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>ridge.pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(ridge.mod, <span class="at">s =</span> <span class="dv">4</span>, <span class="at">newx =</span> x[test, ])</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>((ridge.pred <span class="sc">-</span> y.test)<span class="sc">^</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 142199.2</code></pre>
</div>
</div>
<p>The test MSE is <span class="math inline">\(142{,}199\)</span>. Note that if we had instead simply fit a model with just an intercept, we would have predicted each test observation using the mean of the training observations. In that case, we could compute the test set MSE like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>((<span class="fu">mean</span>(y[train]) <span class="sc">-</span> y.test)<span class="sc">^</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 224669.9</code></pre>
</div>
</div>
<p>We could also get the same result by fitting a ridge regression model with a <em>very</em> large value of <span class="math inline">\(\lambda\)</span>. Note that <code>1e10</code> means <span class="math inline">\(10^{10}\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>ridge.pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(ridge.mod, <span class="at">s =</span> <span class="fl">1e10</span>, <span class="at">newx =</span> x[test, ])</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>((ridge.pred <span class="sc">-</span> y.test)<span class="sc">^</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 224669.8</code></pre>
</div>
</div>
<p>So fitting a ridge regression model with <span class="math inline">\(\lambda=4\)</span> leads to a much lower test MSE than fitting a model with just an intercept. We now check whether there is any benefit to performing ridge regression with <span class="math inline">\(\lambda=4\)</span> instead of just performing least squares regression. Recall that least squares is simply ridge regression with <span class="math inline">\(\lambda=0\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>ridge.pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(ridge.mod, <span class="at">s =</span> <span class="dv">0</span>, <span class="at">newx =</span> x[test, ],</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">exact =</span> T, <span class="at">x =</span> x[train, ], <span class="at">y =</span> y[train])</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>((ridge.pred <span class="sc">-</span> y.test)<span class="sc">^</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 168588.6</code></pre>
</div>
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lm</span>(y <span class="sc">~</span> x, <span class="at">subset =</span> train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = y ~ x, subset = train)

Coefficients:
(Intercept)       xAtBat        xHits       xHmRun        xRuns         xRBI  
   274.0145      -0.3521      -1.6377       5.8145       1.5424       1.1243  
     xWalks       xYears      xCAtBat       xCHits      xCHmRun       xCRuns  
     3.7287     -16.3773      -0.6412       3.1632       3.4008      -0.9739  
      xCRBI      xCWalks     xLeagueN   xDivisionW     xPutOuts     xAssists  
    -0.6005       0.3379     119.1486    -144.0831       0.1976       0.6804  
    xErrors  xNewLeagueN  
    -4.7128     -71.0951  </code></pre>
</div>
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="fu">predict</span>(ridge.mod, <span class="at">s =</span> <span class="dv">0</span>, <span class="at">exact =</span> T, <span class="at">type =</span> <span class="st">"coefficients"</span>,</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> x[train, ], <span class="at">y =</span> y[train])[<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> (Intercept)        AtBat         Hits        HmRun         Runs          RBI 
 274.0200994   -0.3521900   -1.6371383    5.8146692    1.5423361    1.1241837 
       Walks        Years       CAtBat        CHits       CHmRun        CRuns 
   3.7288406  -16.3795195   -0.6411235    3.1629444    3.4005281   -0.9739405 
        CRBI       CWalks      LeagueN    DivisionW      PutOuts      Assists 
  -0.6003976    0.3378422  119.1434637 -144.0853061    0.1976300    0.6804200 
      Errors   NewLeagueN 
  -4.7127879  -71.0898914 </code></pre>
</div>
</div>
<p>In general, if we want to fit a (unpenalized) least squares model, then we should use the <code>lm()</code> function, since that function provides more useful outputs, such as standard errors and p-values for the coefficients.</p>
<p>In general, instead of arbitrarily choosing <span class="math inline">\(\lambda=4\)</span>, it would be better to use cross-validation to choose the tuning parameter <span class="math inline">\(\lambda\)</span>. We can do this using the built-in cross-validation function, <code>cv.glmnet()</code>. By default, the function performs ten-fold cross-validation, though this can be changed using the argument <code>nfolds</code>. Note that we set a random seed first so our results will be reproducible, since the choice of the cross-validation folds is random.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>cv.out <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(x[train, ], y[train], <span class="at">alpha =</span> <span class="dv">0</span>)</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cv.out)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk36-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>bestlam <span class="ot">&lt;-</span> cv.out<span class="sc">$</span>lambda.min</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>bestlam</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 326.0828</code></pre>
</div>
</div>
<p>Therefore, we see that the value of <span class="math inline">\(\lambda\)</span> that results in the smallest cross-validation error is <span class="math inline">\(326\)</span>. What is the test MSE associated with this value of <span class="math inline">\(\lambda\)</span>?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>ridge.pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(ridge.mod, <span class="at">s =</span> bestlam,</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">newx =</span> x[test, ])</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>((ridge.pred <span class="sc">-</span> y.test)<span class="sc">^</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 139856.6</code></pre>
</div>
</div>
<p>This represents a further improvement over the test MSE that we got using <span class="math inline">\(\lambda=4\)</span>. Finally, we refit our ridge regression model on the full data set, using the value of <span class="math inline">\(\lambda\)</span> chosen by cross-validation, and examine the coefficient estimates.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(x, y, <span class="at">alpha =</span> <span class="dv">0</span>)</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="fu">predict</span>(out, <span class="at">type =</span> <span class="st">"coefficients"</span>, <span class="at">s =</span> bestlam)[<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> (Intercept)        AtBat         Hits        HmRun         Runs          RBI 
 15.44383120   0.07715547   0.85911582   0.60103106   1.06369007   0.87936105 
       Walks        Years       CAtBat        CHits       CHmRun        CRuns 
  1.62444617   1.35254778   0.01134999   0.05746654   0.40680157   0.11456224 
        CRBI       CWalks      LeagueN    DivisionW      PutOuts      Assists 
  0.12116504   0.05299202  22.09143197 -79.04032656   0.16619903   0.02941950 
      Errors   NewLeagueN 
 -1.36092945   9.12487765 </code></pre>
</div>
</div>
<p>As expected, none of the coefficients are zero—ridge regression does not perform variable selection!</p>
</section>
<section id="the-lasso" class="level4" data-number="6.1.2.2">
<h4 data-number="6.1.2.2" class="anchored" data-anchor-id="the-lasso"><span class="header-section-number">6.1.2.2</span> The Lasso</h4>
<p>We saw that ridge regression with a wise choice of <span class="math inline">\(\lambda\)</span> can outperform least squares as well as the null model on the <code>Hitters</code> data set. We now ask whether the lasso can yield either a more accurate or a more interpretable model than ridge regression. In order to fit a lasso model, we once again use the <code>glmnet()</code> function; however, this time we use the argument <code>alpha=1</code>. Other than that change, we proceed just as we did in fitting a ridge model.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>lasso.mod <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(x[train, ], y[train], <span class="at">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">lambda =</span> grid)</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(lasso.mod)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm):
collapsing to unique 'x' values</code></pre>
</div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk39-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>We can see from the coefficient plot that depending on the choice of tuning parameter, some of the coefficients will be exactly equal to zero. We now perform cross-validation and compute the associated test error.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>cv.out <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(x[train, ], y[train], <span class="at">alpha =</span> <span class="dv">1</span>)</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cv.out)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk40-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>bestlam <span class="ot">&lt;-</span> cv.out<span class="sc">$</span>lambda.min</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>lasso.pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(lasso.mod, <span class="at">s =</span> bestlam,</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">newx =</span> x[test, ])</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>((lasso.pred <span class="sc">-</span> y.test)<span class="sc">^</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 143673.6</code></pre>
</div>
</div>
<p>This is substantially lower than the test set MSE of the null model and of least squares, and very similar to the test MSE of ridge regression with <span class="math inline">\(\lambda\)</span> chosen by cross-validation.</p>
<p>However, the lasso has a substantial advantage over ridge regression in that the resulting coefficient estimates are sparse. Here we see that 8 of the 19 coefficient estimates are exactly zero. So the lasso model with <span class="math inline">\(\lambda\)</span> chosen by cross-validation contains only eleven variables.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(x, y, <span class="at">alpha =</span> <span class="dv">1</span>, <span class="at">lambda =</span> grid)</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>lasso.coef <span class="ot">&lt;-</span> <span class="fu">predict</span>(out, <span class="at">type =</span> <span class="st">"coefficients"</span>,</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">s =</span> bestlam)[<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>, ]</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>lasso.coef</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept)         AtBat          Hits         HmRun          Runs 
   1.27479059   -0.05497143    2.18034583    0.00000000    0.00000000 
          RBI         Walks         Years        CAtBat         CHits 
   0.00000000    2.29192406   -0.33806109    0.00000000    0.00000000 
       CHmRun         CRuns          CRBI        CWalks       LeagueN 
   0.02825013    0.21628385    0.41712537    0.00000000   20.28615023 
    DivisionW       PutOuts       Assists        Errors    NewLeagueN 
-116.16755870    0.23752385    0.00000000   -0.85629148    0.00000000 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>lasso.coef[lasso.coef <span class="sc">!=</span> <span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept)         AtBat          Hits         Walks         Years 
   1.27479059   -0.05497143    2.18034583    2.29192406   -0.33806109 
       CHmRun         CRuns          CRBI       LeagueN     DivisionW 
   0.02825013    0.21628385    0.41712537   20.28615023 -116.16755870 
      PutOuts        Errors 
   0.23752385   -0.85629148 </code></pre>
</div>
</div>
</section>
</section>
<section id="pcr-and-pls-regression" class="level3" data-number="6.1.3">
<h3 data-number="6.1.3" class="anchored" data-anchor-id="pcr-and-pls-regression"><span class="header-section-number">6.1.3</span> PCR and PLS Regression</h3>
<section id="principal-components-regression" class="level4" data-number="6.1.3.1">
<h4 data-number="6.1.3.1" class="anchored" data-anchor-id="principal-components-regression"><span class="header-section-number">6.1.3.1</span> Principal Components Regression</h4>
<p>Principal components regression (PCR) can be performed using the <code>pcr()</code> function, which is part of the <code>pls</code> library. We now apply PCR to the <code>Hitters</code> data, in order to predict <code>Salary</code>. Again, we ensure that the missing values have been removed from the data, as described in Section 6.5.1.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(pls)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'pls'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:stats':

    loadings</code></pre>
</div>
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2</span>)</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>pcr.fit <span class="ot">&lt;-</span> <span class="fu">pcr</span>(Salary <span class="sc">~</span> ., <span class="at">data =</span> Hitters, <span class="at">scale =</span> <span class="cn">TRUE</span>,</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">validation =</span> <span class="st">"CV"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The syntax for the <code>pcr()</code> function is similar to that for <code>lm()</code>, with a few additional options. Setting <code>scale = TRUE</code> has the effect of <em>standardizing</em> each predictor, using ( 6.6), prior to generating the principal components, so that the scale on which each variable is measured will not have an effect. Setting <code>validation = "CV"</code> causes <code>pcr()</code> to compute the ten-fold cross-validation error for each possible value of <span class="math inline">\(M\)</span>, the number of principal components used. The resulting fit can be examined using <code>summary()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb122"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(pcr.fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Data:   X dimension: 263 19 
    Y dimension: 263 1
Fit method: svdpc
Number of components considered: 19

VALIDATION: RMSEP
Cross-validated using 10 random segments.
       (Intercept)  1 comps  2 comps  3 comps  4 comps  5 comps  6 comps
CV             452    351.9    353.2    355.0    352.8    348.4    343.6
adjCV          452    351.6    352.7    354.4    352.1    347.6    342.7
       7 comps  8 comps  9 comps  10 comps  11 comps  12 comps  13 comps
CV       345.5    347.7    349.6     351.4     352.1     353.5     358.2
adjCV    344.7    346.7    348.5     350.1     350.7     352.0     356.5
       14 comps  15 comps  16 comps  17 comps  18 comps  19 comps
CV        349.7     349.4     339.9     341.6     339.2     339.6
adjCV     348.0     347.7     338.2     339.7     337.2     337.6

TRAINING: % variance explained
        1 comps  2 comps  3 comps  4 comps  5 comps  6 comps  7 comps  8 comps
X         38.31    60.16    70.84    79.03    84.29    88.63    92.26    94.96
Salary    40.63    41.58    42.17    43.22    44.90    46.48    46.69    46.75
        9 comps  10 comps  11 comps  12 comps  13 comps  14 comps  15 comps
X         96.28     97.26     97.98     98.65     99.15     99.47     99.75
Salary    46.86     47.76     47.82     47.85     48.10     50.40     50.55
        16 comps  17 comps  18 comps  19 comps
X          99.89     99.97     99.99    100.00
Salary     53.01     53.85     54.61     54.61</code></pre>
</div>
</div>
<p>The CV score is provided for each possible number of components, ranging from <span class="math inline">\(M=0\)</span> onwards. (We have printed the CV output only up to <span class="math inline">\(M=4\)</span>.) Note that <code>pcr()</code> reports the <em>root mean squared error</em>; in order to obtain the usual MSE, we must square this quantity. For instance, a root mean squared error of <span class="math inline">\(352.8\)</span> corresponds to an MSE of <span class="math inline">\(352.8^2=124{,}468\)</span>.</p>
<p>One can also plot the cross-validation scores using the <code>validationplot()</code> function. Using <code>val.type = "MSEP"</code> will cause the cross-validation MSE to be plotted.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb124"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="fu">validationplot</span>(pcr.fit, <span class="at">val.type =</span> <span class="st">"MSEP"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk44-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>We see that the smallest cross-validation error occurs when <span class="math inline">\(M=18\)</span> components are used. This is barely fewer than <span class="math inline">\(M=19\)</span>, which amounts to simply performing least squares, because when all of the components are used in PCR no dimension reduction occurs. However, from the plot we also see that the cross-validation error is roughly the same when only one component is included in the model. This suggests that a model that uses just a small number of components might suffice.</p>
<p>The <code>summary()</code> function also provides the <em>percentage of variance explained</em> in the predictors and in the response using different numbers of components. This concept is discussed in greater detail in Chapter 12. Briefly, we can think of this as the amount of information about the predictors or the response that is captured using <span class="math inline">\(M\)</span> principal components. For example, setting <span class="math inline">\(M=1\)</span> only captures <span class="math inline">\(38.31\,\%\)</span> of all the variance, or information, in the predictors. In contrast, using <span class="math inline">\(M=5\)</span> increases the value to <span class="math inline">\(84.29\,\%\)</span>. If we were to use all <span class="math inline">\(M=p=19\)</span> components, this would increase to <span class="math inline">\(100\,\%\)</span>.</p>
<p>We now perform PCR on the training data and evaluate its test set performance.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>pcr.fit <span class="ot">&lt;-</span> <span class="fu">pcr</span>(Salary <span class="sc">~</span> ., <span class="at">data =</span> Hitters, <span class="at">subset =</span> train,</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">scale =</span> <span class="cn">TRUE</span>, <span class="at">validation =</span> <span class="st">"CV"</span>)</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a><span class="fu">validationplot</span>(pcr.fit, <span class="at">val.type =</span> <span class="st">"MSEP"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Ch6_LinModSelectRegul_files/figure-html/chunk45-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Now we find that the lowest cross-validation error occurs when <span class="math inline">\(M=5\)</span> components are used. We compute the test MSE as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>pcr.pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(pcr.fit, x[test, ], <span class="at">ncomp =</span> <span class="dv">5</span>)</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>((pcr.pred <span class="sc">-</span> y.test)<span class="sc">^</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 142811.8</code></pre>
</div>
</div>
<p>This test set MSE is competitive with the results obtained using ridge regression and the lasso. However, as a result of the way PCR is implemented, the final model is more difficult to interpret because it does not perform any kind of variable selection or even directly produce coefficient estimates.</p>
<p>Finally, we fit PCR on the full data set, using <span class="math inline">\(M=5\)</span>, the number of components identified by cross-validation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>pcr.fit <span class="ot">&lt;-</span> <span class="fu">pcr</span>(y <span class="sc">~</span> x, <span class="at">scale =</span> <span class="cn">TRUE</span>, <span class="at">ncomp =</span> <span class="dv">5</span>)</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(pcr.fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Data:   X dimension: 263 19 
    Y dimension: 263 1
Fit method: svdpc
Number of components considered: 5
TRAINING: % variance explained
   1 comps  2 comps  3 comps  4 comps  5 comps
X    38.31    60.16    70.84    79.03    84.29
y    40.63    41.58    42.17    43.22    44.90</code></pre>
</div>
</div>
<!-- 
#### Partial Least Squares


We implement partial least squares (PLS) using the `plsr()` function, also in the `pls` library. The syntax is just like that of the `pcr()` function.


::: {.cell}

```{.r .cell-code}
set.seed(1)
pls.fit <- plsr(Salary ~ ., data = Hitters, subset = train, scale = TRUE, validation = "CV")
summary(pls.fit)
```

::: {.cell-output .cell-output-stdout}
```
Data:   X dimension: 131 19 
    Y dimension: 131 1
Fit method: kernelpls
Number of components considered: 19

VALIDATION: RMSEP
Cross-validated using 10 random segments.
       (Intercept)  1 comps  2 comps  3 comps  4 comps  5 comps  6 comps
CV           428.3    325.5    329.9    328.8    339.0    338.9    340.1
adjCV        428.3    325.0    328.2    327.2    336.6    336.1    336.6
       7 comps  8 comps  9 comps  10 comps  11 comps  12 comps  13 comps
CV       339.0    347.1    346.4     343.4     341.5     345.4     356.4
adjCV    336.2    343.4    342.8     340.2     338.3     341.8     351.1
       14 comps  15 comps  16 comps  17 comps  18 comps  19 comps
CV        348.4     349.1     350.0     344.2     344.5     345.0
adjCV     344.2     345.0     345.9     340.4     340.6     341.1

TRAINING: % variance explained
        1 comps  2 comps  3 comps  4 comps  5 comps  6 comps  7 comps  8 comps
X         39.13    48.80    60.09    75.07    78.58    81.12    88.21    90.71
Salary    46.36    50.72    52.23    53.03    54.07    54.77    55.05    55.66
        9 comps  10 comps  11 comps  12 comps  13 comps  14 comps  15 comps
X         93.17     96.05     97.08     97.61     97.97     98.70     99.12
Salary    55.95     56.12     56.47     56.68     57.37     57.76     58.08
        16 comps  17 comps  18 comps  19 comps
X          99.61     99.70     99.95    100.00
Salary     58.17     58.49     58.56     58.62
```
:::

```{.r .cell-code}
validationplot(pls.fit, val.type = "MSEP")
```

::: {.cell-output-display}
![](Ch6_LinModSelectRegul_files/figure-html/chunk48-1.png){width=672}
:::
:::


The lowest cross-validation error occurs when only $M=1$ partial least squares directions are used. We now evaluate the corresponding test set MSE.


::: {.cell}

```{.r .cell-code}
pls.pred <- predict(pls.fit, x[test, ], ncomp = 1)
mean((pls.pred - y.test)^2)
```

::: {.cell-output .cell-output-stdout}
```
[1] 151995.3
```
:::
:::


The test MSE is comparable to, but slightly higher than, the test MSE obtained using ridge regression, the lasso, and PCR.

Finally, we perform PLS using the full data set, using $M=1$, the number of components identified by cross-validation.


::: {.cell}

```{.r .cell-code}
pls.fit <- plsr(Salary ~ ., data = Hitters, scale = TRUE,
    ncomp = 1)
summary(pls.fit)
```

::: {.cell-output .cell-output-stdout}
```
Data:   X dimension: 263 19 
    Y dimension: 263 1
Fit method: kernelpls
Number of components considered: 1
TRAINING: % variance explained
        1 comps
X         38.08
Salary    43.05
```
:::
:::


Notice that the percentage of variance in `Salary` that the one-component PLS fit explains, $43.05\,\%$, is almost as much as that explained using the final five-component model PCR fit, $44.90\,\%$. This is because PCR only attempts to maximize the amount of variance explained in the predictors, while PLS searches for directions that explain variance in both the predictors and the response. 
-->
</section>
</section>
</section>
<section id="exercises" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="exercises"><span class="header-section-number">6.2</span> Exercises</h2>
<p>Prepare the following exercises of Chapter 6 in our course textbook <code>ISLR</code>:</p>
<ul>
<li>Exercise 2</li>
<li>Exercise 4</li>
<li>Exercise 8</li>
<li>Exercise 10</li>
</ul>
<!-- {{< include Ch6_Solutions.qmd >}} -->


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Ch5_ResamplingMethods.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Resampling Methods</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->



</body></html>