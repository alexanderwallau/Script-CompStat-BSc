[
  {
    "objectID": "Ch2_Exercises.html",
    "href": "Ch2_Exercises.html",
    "title": "2  Exercise 7:",
    "section": "",
    "text": "The table below provides a training data set containing six observations, three predictors, and one qualitative response variable. Suppose we wish to use this data set to make a prediction for \\(Y\\) when \\(X_1 = X_2 = X_3 = 0\\) using K-nearest neighbors.\n7. a) Compute the Euclidean distance between each observation and the test point, \\(X_1 = X_2 = X_3 = 0\\).\nAnswer:\n7. b) What is your prediction with \\(K = 1\\)? Why?\nAnswer:\nClosest 1 neighbor is obs5 and thus, our prediction is Green because Green is the \\(Y\\) value associated to obs5.\n7. c) What is your prediction with \\(K = 3\\)? Why?\nAnswer:\nClosest 3 neighbors are obs5, obs6, obs2 and thus, our prediction is Red because it is the \\(Y\\) value associated to obs2 and obs6 (majority rule).\n7. d) If the Bayes decision boundary in this problem is highly nonlinear, then would we expect the best value for \\(K\\) to be large or small? Why?\nAnswer:\nA large value of K means that the \\(Y\\)-values from a large neighborhood are contributing to the prediction at one chosen \\(X\\)-point. This requires that the neighborhood consists of relatively similar \\(Y\\)-values. However, in the case of a highly nonlinear decision boundary, the neighborhoods of similar \\(Y\\)-values become generally small. Therefore, also \\(K\\) must be chosen relatively small so that we can capture more of the non-linear decision boundary."
  },
  {
    "objectID": "Ch2_RLab.html",
    "href": "Ch2_RLab.html",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "",
    "text": "This tutorial aims to serve as an introduction to the software package R. Other very good and much more exhaustive tutorials and useful reference-cards can be found at the following links:\nSome other tutorials:\nWhy R?"
  },
  {
    "objectID": "Ch2_RLab.html#short-glossary",
    "href": "Ch2_RLab.html#short-glossary",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "2.1 Short Glossary",
    "text": "2.1 Short Glossary\nLets start the tutorial with a (very) short glossary:\n\nConsole: The thing with the > sign at the beginning.\nScript file: An ordinary text file with suffix .R. For instance, yourFavoritFileName.R.\nWorking directory: The file-directory you are working in. Useful commands: with getwd() you get the location of your current working directory and setwd() allows you to set a new location for it.\nWorkspace: This is a hidden file (stored in the working directory), where all objects you use (e.g., data, matrices, vectors, variables, functions, etc.) are stored. Useful commands: ls() shows all elements in our current workspace and rm(list=ls()) deletes all elements in our current workspace."
  },
  {
    "objectID": "Ch2_RLab.html#first-steps",
    "href": "Ch2_RLab.html#first-steps",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "2.2 First Steps",
    "text": "2.2 First Steps\nA good idea is to use a script file such as yourFavoritFileName.R in order to store your R commands. You can send single lines or marked regions of your R-code to the console by pressing the keys STRG+ENTER.\nTo begin with baby steps, do some simple computations:\n\n2+2 # and all the others: *,/,-,^2,^3,... \n\n[1] 4\n\n\nNote: Everything that is written after the #-sign is ignored by R, which is very useful to comment your code.\nThe assignment operator <- or = will be your most often used tool. Here an example to create a scalar variable:\n\nx <- 4 \nx\n\n[1] 4\n\n4 -> x # possible but unusual\nx\n\n[1] 4\n\n\nNote: The R community loves the <- assignment operator, which is a very unusual syntax. Alternatively, you can use the more common = operator which is also used in languages like python or matlab.\nAnd now a more interesting object - a vector:\n\ny <- c(2,7,4,1)\ny\n\n[1] 2 7 4 1\n\n\nThe command ls() shows the total content of your current workspace, and the command rm(list=ls()) deletes all elements of your current workspace:\n\nls()\n\n[1] \"x\" \"y\"\n\nrm(list=ls())\nls()\n\ncharacter(0)\n\n\nNote: RStudio’s Environment pane also lists all the elements in your current workspace. That is, the command ls() becomes a bit obsolete when working with RStudio.\nLet’s try how we can compute with vectors and scalars in R.\n\nx <- 4\ny <- c(2,7,4,1)\n\nx*y # each element in the vector, y, is multiplied by the scalar, x.\n\n[1]  8 28 16  4\n\ny*y # this is a term by term product of the elements in y\n\n[1]  4 49 16  1\n\n\nPerforming vector multiplications as you might expect from your last math-course, e.g., an outer product: \\(y\\,y^\\top\\):\n\ny %*% t(y)\n\n     [,1] [,2] [,3] [,4]\n[1,]    4   14    8    2\n[2,]   14   49   28    7\n[3,]    8   28   16    4\n[4,]    2    7    4    1\n\n\nOr an inner product \\(y^\\top y\\):\n\nt(y) %*% y\n\n     [,1]\n[1,]   70\n\n\nNote: Sometimes, R’s treatment of vectors can be annoying. The product y %*% y is treated as the product t(y) %*% y.\nThe term-by-term execution as in the above example, y*y, is actually a central strength of R. We can conduct many operations vector-wisely:\n\ny^2\n\n[1]  4 49 16  1\n\nlog(y)\n\n[1] 0.6931472 1.9459101 1.3862944 0.0000000\n\nexp(y)\n\n[1]    7.389056 1096.633158   54.598150    2.718282\n\ny-mean(y)\n\n[1] -1.5  3.5  0.5 -2.5\n\n(y-mean(y))/sd(y) # standardization \n\n[1] -0.5669467  1.3228757  0.1889822 -0.9449112\n\n\nThis is a central characteristic of so called matrix based languages like R (or Matlab). Other programming languages often have to use loops instead:\n\nN <- length(y)\n1:N\n\ny.sq <- numeric(N)\ny.sq\n\nfor(i in 1:N){\n  y.sq[i] <- y[i]^2\n  if(i == N){\n    print(y.sq)\n  }\n}\n\nThe for()-loop is the most common loop. But there is also a while()-loop and a repeat()-loop. However, loops in R can be rather slow, therefore, try to avoid them!\n\nUseful commands to produce sequences of numbers:\n\n1:10\n-10:10\n?seq # Help for the seq()-function\nseq(from=1, to=100, by=7)\n\nUsing the sequence command 1:16, we can go for our first matrix:\n\n?matrix\nA <- matrix(data=1:16, nrow=4, ncol=4)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\nA <- matrix(1:16, 4, 4)\n\nNote that a matrix has always two dimensions, but a vector has only one dimension:\n\ndim(A)    # Dimension of matrix A?\n\n[1] 4 4\n\ndim(y)    # dim() does not operate on vectors.\n\nNULL\n\nlength(y) # Length of vector y?\n\n[1] 4\n\n\nLets play a bit with the matrix A and the vector y. As we have seen in the loop above, the []-operator selects elements of vectors and matrices:\n\nA[,1]\nA[4,4]\ny[c(1,4)]\n\nThis can be done on a more logical basis, too. For example, if you want to know which elements in the first column of matrix A are strictly greater than 2:\n\nA[,1][A[,1]>2]\n\n[1] 3 4\n\n# Note that this give you a boolean vector:\nA[,1]>2\n\n[1] FALSE FALSE  TRUE  TRUE\n\n# And you can use it in a non-sense relation, too:\ny[A[,1]>2]\n\n[1] 4 1\n\n\nNote: Logical operations return so-called boolean objects, i.e., either a TRUE or a FALSE. For instance, if we ask R whether 1>2 we get the answer FALSE."
  },
  {
    "objectID": "Ch2_RLab.html#further-data-objects",
    "href": "Ch2_RLab.html#further-data-objects",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "2.3 Further Data Objects",
    "text": "2.3 Further Data Objects\nBesides classical data objects such as scalars, vectors, and matrices there are three further data objects in R:\n\n1. The array: As a matrix but with more dimensions. Here is an example of a \\(2\\times 2\\times 2\\)-dimensional array:\n\nmyFirst.Array <- array(c(1:8), dim=c(2,2,2)) # Take a look at it!\n\n\n\n2. The list: In lists you can organize different kinds of data. E.g., consider the following example:\n\nmyFirst.List <- list(\"Some_Numbers\" = c(66, 76, 55, 12, 4, 66, 8, 99), \n                     \"Animals\"      = c(\"Rabbit\", \"Cat\", \"Elefant\"),\n                     \"My_Series\"    = c(30:1)) \n\nA very useful function to find specific values and entries within lists is the str()-function:\n\nstr(myFirst.List)\n\nList of 3\n $ Some_Numbers: num [1:8] 66 76 55 12 4 66 8 99\n $ Animals     : chr [1:3] \"Rabbit\" \"Cat\" \"Elefant\"\n $ My_Series   : int [1:30] 30 29 28 27 26 25 24 23 22 21 ...\n\n\n\n\n3. The data frame: A data.frame is a list-object but with some more formal restrictions (e.g., equal number of rows for all columns). As indicated by its name, a data.frame-object is designed to store data:\n\nmyFirst.Dataframe <- data.frame(\"Credit_Default\"   = c( 0, 0, 1, 0, 1, 1), \n                                \"Age\"              = c(35,41,55,36,44,26), \n                                \"Loan_in_1000_EUR\" = c(55,65,23,12,98,76)) \n# Take a look at it!"
  },
  {
    "objectID": "Ch2_RLab.html#simple-regression-analysis-using-r",
    "href": "Ch2_RLab.html#simple-regression-analysis-using-r",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "2.4 Simple Regression Analysis using R",
    "text": "2.4 Simple Regression Analysis using R\nAlright, let’s do some statistics with real data. You can download the data HERE. Save it on your computer, at a place where you can find it, and give the path (e.g. \"C:\\textbackslash path\\textbackslash auto.data.csv\", which references to the data, to the file-argument of the function read.csv():\n\n# ATTENTION! YOU HAVE TO CHANGE \"\\\" TO \"/\":\nauto.data <- read.csv(file=\"C:/your_path/autodata.txt\", header=TRUE)\nhead(auto.data)\n\n\n\nIf you have problems to read the data into R, go on with these commands. (For this you need a working internet connection!):\n\n# install.packages(\"readr\")\nlibrary(\"readr\")\nauto.data <- suppressMessages(read_csv(file = \"https://cdn.rawgit.com/lidom/Teaching_Repo/bc692b56/autodata.csv\",col_names = TRUE))\n# head(auto.data)\n\n\n\nYou can select specific variables of the auto.data using the $-operator:\n\ngasolin.consumption      <- auto.data$MPG.city\ncar.weight               <- auto.data$Weight\n## Take a look at the first elements of these vectors:\nhead(cbind(gasolin.consumption,car.weight))\n\n     gasolin.consumption car.weight\n[1,]                  25       2705\n[2,]                  18       3560\n[3,]                  20       3375\n[4,]                  19       3405\n[5,]                  22       3640\n[6,]                  22       2880\n\n\n\n\nThis is how you can produce your first plot:\n\n## Plot the data:\nplot(y=gasolin.consumption, x=car.weight, \n     xlab=\"Car-Weight (US-Pounds)\", \n     ylab=\"Consumption (Miles/Gallon)\", \n     main=\"Buy Light-Weight Cars!\")\n\n\n\n\nFigure 2.1: Scatterplot of Gasoline consumption (mpg) vs. car weight.\n\n\n\n\n\n\nAs a first step, we might assume a simple kind of linear relationship between the variables gasolin.consumption and car.weight. Let us assume that the data was generated by the following simple regression model: \\[\ny_i=\\alpha+\\beta_1 x_i+\\varepsilon_i,\\quad i=1,\\dots,n\n\\] where \\(y_i\\) denotes the gasoline-consumption, \\(x_i\\) the weight of car \\(i\\), and \\(\\varepsilon_i\\) is a mean zero constant variance noise term. (This is clearly a non-sense model!)\nThe command lm() computes the estimates of this linear regression model. The command (in fact it’s a method) summary() computes further quantities of general interest from the object that was returned from the lm() function.\n\nlm.result   <- lm(gasolin.consumption~car.weight)\nlm.summary  <- summary(lm.result)\nlm.summary\n\n\nCall:\nlm(formula = gasolin.consumption ~ car.weight)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-6.7946 -1.9711  0.0249  1.1855 13.8278 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 47.048353   1.679912   28.01   <2e-16 ***\ncar.weight  -0.008032   0.000537  -14.96   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.038 on 91 degrees of freedom\nMultiple R-squared:  0.7109,    Adjusted R-squared:  0.7077 \nF-statistic: 223.8 on 1 and 91 DF,  p-value: < 2.2e-16\n\n\n\n\nOf course, we want to have a possibility to access all the quantities computed so far, e.g., in order to plot the results. This can be done as following:\n\n## Accessing the computed quantities\nnames(lm.summary) ## Alternatively: str(lm.summary)\n\n [1] \"call\"          \"terms\"         \"residuals\"     \"coefficients\" \n [5] \"aliased\"       \"sigma\"         \"df\"            \"r.squared\"    \n [9] \"adj.r.squared\" \"fstatistic\"    \"cov.unscaled\" \n\nalpha <- lm.summary$coefficients[1]\nbeta  <- lm.summary$coefficients[2]\n\n## Plot all:\nplot(y=gasolin.consumption, x=car.weight, \n     xlab=\"Car-Weight (US-Pounds)\", \n     ylab=\"Consumption (Miles/Gallon)\", \n     main=\"Buy light-weight Cars!\")\nabline(a=alpha, \n       b=beta, col=\"red\")\n\n\n\n\nScatterplot of Gasoline consumption (mpg) vs. car weight plus linear regression fit."
  },
  {
    "objectID": "Ch2_RLab.html#programming-in-r",
    "href": "Ch2_RLab.html#programming-in-r",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "2.5 Programming in R",
    "text": "2.5 Programming in R\nLet’s write, i.e., program our own R-function for estimating linear regression models. In order to be able to validate our function, we start with simulating data for which we then know all true parameters.\nSimulating data is like being the “Data-God”: For instance, we generate realizations of the error term \\(\\varepsilon_i\\), i.e., something which we never observe in real data.\nLet us consider the following multiple regression model:\n\\[y_i=\\beta_1 +\\beta_2 x_{2i}+\\beta_3 x_{3i}+\\varepsilon_{i},\\quad i=1,\\dots,n,\\] where \\(\\varepsilon_{i}\\) is a heteroscedastic error term \\[\\varepsilon_{i}\\sim N(0,\\sigma_i^2),\\quad \\sigma_i=|x_{3i}|,\\]\nand where for all \\(i=1,\\dots,n=50\\):\n\n\\(x_{2i}\\sim N(10,1.5^2)\\)\n\\(x_{3i}\\) comes from a t-distribution with 5 degrees of freedom and non-centrality parameter 2\n\n\nset.seed(109) # Sets the \"seed\" of the random number generators:\nn   <- 50     # Number of observations\n\n## Generate two explanatory variables plus an intercept-variable:\nX.1 <- rep(1, n)                 # Intercept\nX.2 <- rnorm(n, mean=10, sd=1.5) # Draw realizations form a normal distr.\nX.3 <- rt(n, df=5, ncp=2)        # Draw realizations form a t-distr.\nX   <- cbind(X.1, X.2, X.3)      # Save as a Nx3-dimensional data matrix.\n\nOK, we have regressors, i.e., data that we also have in real data sets.\nNow we define the elements of the \\(\\beta\\)-vector. Be aware of the difference: In real data sets we do not know the true \\(\\beta\\)-vector, but try to estimate it. However, when simulating data, we determine (as “Data-Gods”) the true \\(\\beta\\)-vector and can compare our estimate \\(\\hat{\\beta}\\) with the true \\(\\beta\\):\n\n## Define the slope-coefficients\nbeta.vec  <- c(1,-5,5)\n\n\nWe still need to simulate realizations of the dependent variable \\(y_i\\). Remember that \\(y_i=\\beta_1 x_{1i}+\\beta_1 x_{2i}+\\beta_3 x_{3i}+\\varepsilon_{i}\\). That is, we only need realizations from the error terms \\(\\varepsilon_i\\) in order to compute the realizations from \\(y_i\\). This is how you can simulate realizations from the heteroscedastic error terms \\(\\varepsilon_i\\):\n\n## Generate realizations from the heteroscadastic error term\neps       <- rnorm(n, mean=0, sd=abs(X.3))\n\nTake a look at the heteroscedasticity in the error term:\n\nplot(y=eps, x=X.3, \n     main=\"Realizations of the \\nHeteroscedastic Error Term\")\n\n\n\n\nScatterplot of error term realizations (usually unknown) versus the predictor values of X.3.\n\n\n\n\nWith the (pseudo-random) realizations from \\(\\varepsilon_i\\), we can finally generate realizations from the dependent variable \\(y_i\\):\n\n## Dependent variable:\ny   <- X %*% beta.vec + eps\n\nLet’s take a look at the data:\n\nmydata    <- data.frame(\"Y\"=y, \"X.1\"=X.1, \"X.2\"=X.2, \"X.3\"=X.3)\npairs(mydata[,-2]) # The '-2' removes the intercept variable \"X.1\"\n\n\n\n\n\n\nOnce we have data, we can compute the OLS estimate of the true \\(\\beta\\) vector. Remember the formula: \\[\\hat{\\beta}=(X^\\top X)^{-1}X^\\top y\\] In R-Code this is: \\((X^\\top X)^{-1}=\\)solve(t(X) %*% X), i.e.:\n\n## Computation of the beta-Vector:\nbeta.hat <- solve(t(X) %*% X) %*% t(X) %*% y\nbeta.hat\n\n         [,1]\nX.1 -2.609634\nX.2 -4.692735\nX.3  5.078342\n\n\n\n\nWell done. Using the above lines of code we can easily program our own myOLSFun() function!\n\nmyOLSFun <- function(y, x, add.intercept=FALSE){\n  \n  ## Number of Observations:\n  n         <- length(y)\n  \n  ## Add an intercept to x:\n  if(add.intercept){\n    Intercept <- rep(1, n)\n    x         <- cbind(Intercept, x)\n  }\n  \n  ## Estimation of the slope-parameters:\n  beta.hat.vec <- solve(t(x) %*% x) %*% t(x) %*% y\n  \n  ## Return the result:\n  return(beta.hat.vec)\n}\n\n## Run the function:\nmyOLSFun(y=y, x=X)\n\n         [,1]\nX.1 -2.609634\nX.2 -4.692735\nX.3  5.078342\n\n\n\n\nCan you extend the function for the computation of the covariance matrix of the slope-estimates, several measures of fits (R\\(^2\\), adj.-R\\(^2\\), etc.), t-tests, …?"
  },
  {
    "objectID": "Ch2_RLab.html#r-packages",
    "href": "Ch2_RLab.html#r-packages",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "2.6 R-packages",
    "text": "2.6 R-packages\nOne of the best features in R are its contributed packages. The list of all packages on CRAN is impressive! Take a look at it HERE\nFor instance, nice plots can be produced using the R-package is ggplot2. You can find an intro do this package HERE.\n\n# install.packages(\"ggplot2\")\nlibrary(\"ggplot2\")\n\nqplot(Sepal.Length, Petal.Length, data = iris, color = Species)\n\n\n\n\n\n\n\n\n\n\nOf course, ggplot2 concerns “only” plotting, but you’ll find R-packages for almost any statistical method out there."
  },
  {
    "objectID": "Ch2_RLab.html#tidyverse",
    "href": "Ch2_RLab.html#tidyverse",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "2.7 Tidyverse",
    "text": "2.7 Tidyverse\nThe tidyverse package is a collection of packages that lets you import, manipulate, explore, visualize and model data in a harmonized and consistent way which helps you to be more productive.\nInstalling the tidyverse package:\n\ninstall.packages(\"tidyverse\")\n\nTo use the tidyverse package load it using the library() function:\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──\n\n\n✔ tibble  3.1.7      ✔ dplyr   1.0.10\n✔ tidyr   1.1.2      ✔ stringr 1.4.0 \n✔ purrr   0.3.4      ✔ forcats 0.5.1 \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\nChick Weight Data\nR comes with many datasets installed. We will use the ChickWeight dataset to learn (a little) about the tidyverse. The help system gives a basic summary of the experiment from which the data was collect:\n\n“The body weights of the chicks were measured at birth and every second day thereafter until day 20. They were also measured on day 21. There were four groups of chicks on different protein diets.”\n\nYou can get more information, including references by typing:\n\nhelp(\"ChickWeight\")\n\nThe Data:  There are 578 observations (rows) and 4 variables:\n\nChick – unique ID for each chick.\nDiet – one of four protein diets.\nTime – number of days since birth.\nweight – body weight of chick in grams.\n\nNote: weight has a lower case w (recall R is case sensitive).\nStore the data locally:\n\nChickWeight %>%\n  dplyr::select(Chick, Diet, Time, weight) %>% \n  dplyr::arrange(Chick, Diet, Time) %>% \n  write_csv(\"ChickWeight.csv\")\n\nFirst we will import the data from a file called ChickWeight.csv using the read_csv() function from the readr package (part of the tidyverse). The first thing to do, outside of R, is to open the file ChickWeight.csv to check what it contains and that it makes sense. Now we can import the data as follows:\n\nCW <- readr::read_csv(\"ChickWeight.csv\")\n\nRows: 578 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (4): Chick, Diet, Time, weight\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nIf all goes well then the data is now stored in an R object called CW. If you get the following error message then you need to change the working directory to where the data is stored:\n\nError: ‘ChickWeight.csv’ does not exist in current working directory …\n\nChanging the working directory: In RStudio you can use the menu bar (“Session - Set Working Directory - Choose Directory…”). Alternatively, you can use the function setwd(). Last but not least, to avoid issues with brocken paths to files and data sets, use RStudios’ “Project” tools.\nLooking at the Dataset: To look at the data type just type the object (dataset) name:\n\nCW\n\n# A tibble: 578 × 4\n   Chick  Diet  Time weight\n   <dbl> <dbl> <dbl>  <dbl>\n 1    18     1     0     39\n 2    18     1     2     35\n 3    16     1     0     41\n 4    16     1     2     45\n 5    16     1     4     49\n 6    16     1     6     51\n 7    16     1     8     57\n 8    16     1    10     51\n 9    16     1    12     54\n10    15     1     0     41\n# … with 568 more rows\n\n\nIf there are too many variables then not all them may be printed. To overcome this issue we can use the glimpse() function which makes it possible to see every column in your dataset (called a “data frame” in R speak).\n\nglimpse(CW)\n\nRows: 578\nColumns: 4\n$ Chick  <dbl> 18, 18, 16, 16, 16, 16, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15,…\n$ Diet   <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ Time   <dbl> 0, 2, 0, 2, 4, 6, 8, 10, 12, 0, 2, 4, 6, 8, 10, 12, 14, 0, 2, 4…\n$ weight <dbl> 39, 35, 41, 45, 49, 51, 57, 51, 54, 41, 49, 56, 64, 68, 68, 67,…\n\n\nThe function View() allows for a spread-sheet type of view on the data:\n\nView(CW)\n\n\n2.7.1 Tidyverse: Plotting Basics\nTo visualize the chick weight data, we will use the ggplot2 package (part of the tidyverse). Our interest is in seeing how the weight changes over time for the chicks by diet. For the moment don’t worry too much about the details just try to build your own understanding and logic. To learn more try different things even if you get an error messages.\nLet’s plot the weight data (vertical axis) over time (horizontal axis). Generally, ggplot2 works in layers. The following codes generates an empty plot:\n\n# An empty plot\nggplot(CW, aes(Time, weight))  \n\n\n\n\nEmpty ggplot layer.\n\n\n\n\nTo the empty plot, one can add fuhrer layers:\n\n# Adding a scatter plot \nggplot(CW, aes(Time, weight)) + geom_point() \n\n\n\n\nAdding a scatter plot layer to the empty ggplot layer.\n\n\n\n\nAdd color for Diet. The graph above does not differentiate between the diets. Let’s use a different color for each diet.\n\n# Adding colour for diet\nggplot(CW,aes(Time,weight,colour=factor(Diet))) +\n  geom_point() \n\n\n\n\nAdding a further layer for shown the effect of the Diet.\n\n\n\n\nIt is difficult to conclude anything from this graph as the points are printed on top of one another (with diet 1 underneath and diet 4 at the top).\nTo improve the plot, it will be handy to store Diet and Time as a factor variables.\nFactor Variables: Before we continue, we have to make an important change to the CW dataset by making Diet and Time factor variables. This means that R will treat them as categorical variables (see the <fct> variables below) instead of continuous variables. It will simplify our coding. The next section will explain the mutate() function.\n\nCW <- mutate(CW, Diet = factor(Diet))\nCW <- mutate(CW, Time = factor(Time))\nglimpse(CW)\n\nRows: 578\nColumns: 4\n$ Chick  <dbl> 18, 18, 16, 16, 16, 16, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15,…\n$ Diet   <fct> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ Time   <fct> 0, 2, 0, 2, 4, 6, 8, 10, 12, 0, 2, 4, 6, 8, 10, 12, 14, 0, 2, 4…\n$ weight <dbl> 39, 35, 41, 45, 49, 51, 57, 51, 54, 41, 49, 56, 64, 68, 68, 67,…\n\n\nThe facet_wrap() function: To plot each diet separately in a grid using facet_wrap():\n\n# Adding jitter to the points\nggplot(CW, aes(Time, weight, colour=Diet)) +\n  geom_point() +\n  facet_wrap(~Diet) +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInterpretation: Diet 4 has the least variability but we can’t really say anything about the mean effect of each diet although diet 3 seems to have the highest.\nNext we will plot the mean changes over time for each diet using the stat_summary() function:\n\nggplot(CW, aes(Time, weight, \n               group=Diet, colour=Diet)) +\n  stat_summary(fun=\"mean\", geom=\"line\") \n\n\n\n\nInterpretation: We can see that diet 3 has the highest mean weight gains by the end of the experiment. However, we don’t have any information about the variation (uncertainty) in the data.\nTo see variation between the different diets we use geom_boxplot to plot a box-whisker plot. A note of caution is that the number of chicks per diet is relatively low to produce this plot.\n\nggplot(CW, aes(Time, weight, colour=Diet)) +\n  facet_wrap(~Diet) +\n  geom_boxplot() +\n  theme(legend.position = \"none\") +\n  ggtitle(\"Chick Weight over Time by Diet\")\n\n\n\n\nInterpretation: Diet 3 seems to have the highest “average” weight gain but it has more variation than diet 4 which is consistent with our findings so far.\nLet’s finish with a plot that you might include in a publication.\n\nggplot(CW, aes(Time, weight, group=Diet, \n                             colour=Diet)) +\n  facet_wrap(~Diet) +\n  geom_point() +\n  # geom_jitter() +\n  stat_summary(fun=\"mean\", geom=\"line\",\n               colour=\"black\") +\n  theme(legend.position = \"none\") +\n  ggtitle(\"Chick Weight over Time by Diet\") + \n  xlab(\"Time (days)\") +\n  ylab(\"Weight (grams)\")\n\n\n\n\n\n\n2.7.2 Tidyverse: Data Wrangling Basics\n\n\n\nIn this section we will learn how to wrangle (manipulate) datasets using the tidyverse package. Let’s start with the mutate(), select(), rename(), filter() and arrange() functions.\nmutate(): Adds a new variable (column) or modifies an existing one. We already used this above to create factor variables.\n\n# Added a column\nCWm1 <- mutate(CW, weightKg = weight/1000)\nCWm1\n\n# A tibble: 578 × 5\n  Chick Diet  Time  weight weightKg\n  <dbl> <fct> <fct>  <dbl>    <dbl>\n1    18 1     0         39    0.039\n2    18 1     2         35    0.035\n3    16 1     0         41    0.041\n# … with 575 more rows\n\n# Modify an existing column\nCWm2 <- mutate(CW, Diet = str_c(\"Diet \", Diet))\nCWm2\n\n# A tibble: 578 × 4\n  Chick Diet   Time  weight\n  <dbl> <chr>  <fct>  <dbl>\n1    18 Diet 1 0         39\n2    18 Diet 1 2         35\n3    16 Diet 1 0         41\n# … with 575 more rows\n\n\nselect(): Keeps, drops or reorders variables.\n\n# Drop the weight variable from CWm1 using minus\ndplyr::select(CWm1, -weight)\n\n# A tibble: 578 × 4\n  Chick Diet  Time  weightKg\n  <dbl> <fct> <fct>    <dbl>\n1    18 1     0        0.039\n2    18 1     2        0.035\n3    16 1     0        0.041\n# … with 575 more rows\n\n# Keep variables Time, Diet and weightKg\ndplyr::select(CWm1, Chick, Time, Diet, weightKg)\n\n# A tibble: 578 × 4\n  Chick Time  Diet  weightKg\n  <dbl> <fct> <fct>    <dbl>\n1    18 0     1        0.039\n2    18 2     1        0.035\n3    16 0     1        0.041\n# … with 575 more rows\n\n\nrename(): Renames variables whilst keeping all variables.\n\ndplyr::rename(CW, Group = Diet, Weight = weight)\n\n# A tibble: 578 × 4\n  Chick Group Time  Weight\n  <dbl> <fct> <fct>  <dbl>\n1    18 1     0         39\n2    18 1     2         35\n3    16 1     0         41\n# … with 575 more rows\n\n\nfilter(): Keeps or drops observations (rows).\n\ndplyr::filter(CW, Time==21 & weight>300)\n\n# A tibble: 8 × 4\n  Chick Diet  Time  weight\n  <dbl> <fct> <fct>  <dbl>\n1     7 1     21       305\n2    29 2     21       309\n3    21 2     21       331\n# … with 5 more rows\n\n\nFor comparing values in vectors use: < (less than), > (greater than), <= (less than and equal to), >= (greater than and equal to), == (equal to) and != (not equal to). These can be combined logically using & (and) and | (or).\narrange(): Changes the order of the observations.\n\ndplyr::arrange(CW, Chick, Time)\n\n# A tibble: 578 × 4\n  Chick Diet  Time  weight\n  <dbl> <fct> <fct>  <dbl>\n1     1 1     0         42\n2     1 1     2         51\n3     1 1     4         59\n# … with 575 more rows\n\ndplyr::arrange(CW, desc(weight))\n\n# A tibble: 578 × 4\n  Chick Diet  Time  weight\n  <dbl> <fct> <fct>  <dbl>\n1    35 3     21       373\n2    35 3     20       361\n3    34 3     21       341\n# … with 575 more rows\n\n\nWhat does the desc() do? Try using desc(Time).\n\n\n2.7.3 The pipe operator %>%\nIn reality you will end up doing multiple data wrangling steps that you want to save. The pipe operator %>% makes your code nice and readable:\n\nCW21 <- CW %>% \n  dplyr::filter(Time %in% c(0, 21)) %>% \n  dplyr::rename(Weight = weight) %>% \n  dplyr::mutate(Group = factor(str_c(\"Diet \", Diet))) %>% \n  dplyr::select(Chick, Group, Time, Weight) %>% \n  dplyr::arrange(Chick, Time) \nCW21\n\n# A tibble: 95 × 4\n  Chick Group  Time  Weight\n  <dbl> <fct>  <fct>  <dbl>\n1     1 Diet 1 0         42\n2     1 Diet 1 21       205\n3     2 Diet 1 0         40\n# … with 92 more rows\n\n\nHint: To understand the code above we should read the pipe operator %>% as “then”.\n\nCreate a new dataset (object) called CW21 using dataset CW then keep the data for days 0 and 21 then rename variable weight to Weight then create a variable called Group then keep variables Chick, Group, Time and Weight and then finally arrange the data by variables Chick and Time.\n\nThis is the same code:\n\nCW21 <- CW %>% \n  dplyr::filter(., Time %in% c(0, 21)) %>% \n  dplyr::rename(., Weight = weight) %>% \n  dplyr::mutate(., Group=factor(str_c(\"Diet \",Diet))) %>% \n  dplyr::select(., Chick, Group, Time, Weight) %>% \n  dplyr::arrange(., Chick, Time) \n\nThe pipe operator, %>%, replaces the dots (.) with whatever is returned from code preceding it. For example, the dot in filter(., Time %in% c(0, 21)) is replaced by CW. The output of the filter(...) then replaces the dot in rename(., Weight = weight) and so on. Think of it as a data assembly line with each function doing its thing and passing it to the next.\n\n\n2.7.4 The group_by() function\nFrom the data visualizations above we concluded that the diet 3 has the highest mean and diet 4 the least variation. In this section, we will quantify the effects of the diets using summmary statistics. We start by looking at the number of observations and the mean by diet and time.\n\nmnsdCW <- CW %>% \n  dplyr::group_by(Diet, Time) %>% \n  dplyr::summarise(N = n(), Mean = mean(weight)) %>% \n  dplyr::arrange(Diet, Time)\n\n`summarise()` has grouped output by 'Diet'. You can override using the\n`.groups` argument.\n\nmnsdCW\n\n# A tibble: 48 × 4\n# Groups:   Diet [4]\n  Diet  Time      N  Mean\n  <fct> <fct> <int> <dbl>\n1 1     0        20  41.4\n2 1     2        20  47.2\n3 1     4        19  56.5\n# … with 45 more rows\n\n\nFor each distinct combination of Diet and Time, the chick weight data is summarized into the number of observations (N) and the mean (Mean) of weight.\nFurther summaries: Let’s also calculate the standard deviation, median, minimum and maximum values but only at days 0 and 21.\n\nsumCW <-  CW %>% \n  dplyr::filter(Time %in% c(0, 21)) %>% \n  dplyr::group_by(Diet, Time) %>% \n  dplyr::summarise(N = n(),\n            Mean = mean(weight),\n            SD = sd(weight),\n            Median = median(weight),\n            Min = min(weight),\n            Max = max(weight)) %>% \n  dplyr::arrange(Diet, Time)\n\n`summarise()` has grouped output by 'Diet'. You can override using the\n`.groups` argument.\n\nsumCW\n\n# A tibble: 8 × 8\n# Groups:   Diet [4]\n  Diet  Time      N  Mean     SD Median   Min   Max\n  <fct> <fct> <int> <dbl>  <dbl>  <dbl> <dbl> <dbl>\n1 1     0        20  41.4  0.995   41      39    43\n2 1     21       16 178.  58.7    166      96   305\n3 2     0        10  40.7  1.49    40.5    39    43\n# … with 5 more rows\n\n\nLet’s make the summaries “prettier”, say, for a report or publication.\n\nlibrary(\"knitr\") # to use the kable() function\nprettySumCW <- sumCW %>% \n dplyr::mutate(`Mean (SD)` = str_c(format(Mean, digits=1),\n           \" (\", format(SD, digits=2), \")\")) %>% \n dplyr::mutate(Range = str_c(Min, \" - \", Max)) %>% \n dplyr::select(Diet, Time, N, `Mean (SD)`, Median, Range) %>%\n dplyr::arrange(Diet, Time) %>% \n kable(format = \"latex\")\nprettySumCW\n\n\n\n\n\n \n  \n    Diet \n    Time \n    N \n    Mean (SD) \n    Median \n    Range \n  \n \n\n  \n    1 \n    0 \n    20 \n    41 ( 0.99) \n    41.0 \n    39 - 43 \n  \n  \n    1 \n    21 \n    16 \n    178 (58.70) \n    166.0 \n    96 - 305 \n  \n  \n    2 \n    0 \n    10 \n    41 ( 1.5) \n    40.5 \n    39 - 43 \n  \n  \n    2 \n    21 \n    10 \n    215 (78.1) \n    212.5 \n    74 - 331 \n  \n  \n    3 \n    0 \n    10 \n    41 ( 1) \n    41.0 \n    39 - 42 \n  \n  \n    3 \n    21 \n    10 \n    270 (72) \n    281.0 \n    147 - 373 \n  \n  \n    4 \n    0 \n    10 \n    41 ( 1.1) \n    41.0 \n    39 - 42 \n  \n  \n    4 \n    21 \n    9 \n    239 (43.3) \n    237.0 \n    196 - 322 \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInterpretation: This summary table offers the same interpretation as before, namely that diet 3 has the highest mean and median weights at day 21 but a higher variation than group 4. However it should be noted that at day 21, diet 1 lost 4 chicks from 20 that started and diet 4 lost 1 from 10. This could be a sign of some health related issues."
  },
  {
    "objectID": "Ch2_RLab.html#further-links",
    "href": "Ch2_RLab.html#further-links",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "2.8 Further Links",
    "text": "2.8 Further Links\n\n2.8.1 Further R-Intros\n\nhttps://eddelbuettel.github.io/gsir-te/Getting-Started-in-R.pdf\nhttps://www.datacamp.com/courses/free-introduction-to-r\nhttps://swcarpentry.github.io/r-novice-gapminder/\nhttps://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects\n\n\n\n2.8.2 Version Control (Git/GitHub)\n\nhttps://support.rstudio.com/hc/en-us/articles/200532077-Version-Control-with-Git-and-SVN\nhttp://happygitwithr.com/\nhttps://www.gitkraken.com/\n\n\n\n2.8.3 R-Ladies\n\nhttps://rladies.org/"
  },
  {
    "objectID": "Ch2_Exercises.html#e-xercise-8",
    "href": "Ch2_Exercises.html#e-xercise-8",
    "title": "2  Exercise 7:",
    "section": "2.1 E xercise 8:",
    "text": "2.1 E xercise 8:\nThis exercise relates to the College data set, which can be found in the file College.csv. It contains a number of variables for \\(777\\) different universities and colleges in the US. The variables are:\n\nPrivate : Public/private indicator\nApps : Number of applications received\nAccept : Number of applicants accepted\nEnroll : Number of new students enrolled\nTop10perc : New students from top 10% of high school class\nTop25perc : New students from top 25% of high school class\nF.Undergrad : Number of full-time undergraduates\nP.Undergrad : Number of part-time undergraduates\nOutstate : Out-of-state tuition\nRoom.Board : Room and board costs\nBooks : Estimated book costs\nPersonal : Estimated personal spending\nPhD : Percent of faculty with Ph.D.’s\nTerminal : Percent of faculty with terminal degree\nS.F.Ratio : Student/faculty ratio\nperc.alumni : Percent of alumni who donate\nExpend : Instructional expenditure per student\nGrad.Rate : Graduation rate\n\n8. a) Use the read.csv() function to read the data into R. Call the loaded data college. Make sure that you have the directory set to the correct location for the data.\nAnswer:\n\n# Store data into dataframe college\ncollege <- read.csv(\"DATA/College.csv\")\n\n# Print first 10 rows and 5 collumns of the data\nprint(college[c(1:10),c(1:5)])\n\n                              X Private Apps Accept Enroll\n1  Abilene Christian University     Yes 1660   1232    721\n2            Adelphi University     Yes 2186   1924    512\n3                Adrian College     Yes 1428   1097    336\n4           Agnes Scott College     Yes  417    349    137\n5     Alaska Pacific University     Yes  193    146     55\n6             Albertson College     Yes  587    479    158\n7       Albertus Magnus College     Yes  353    340    103\n8                Albion College     Yes 1899   1720    489\n9              Albright College     Yes 1038    839    227\n10    Alderson-Broaddus College     Yes  582    498    172\n\n\n8. b) Look at the data using the fix() function.\nAnswer:\nYou should notice that the first column is just the name of each university. We don’t really want R to treat this as data. However, it may be handy to have these names for later. Try the following commands:\n\n# Store row names\nrownames(college) <- college[,1]\n\n# pops up a window for data visualization\n# fix(college)\n\nYou should see that there is now a row.names column with the name of each university recorded. This means that R has given each row a name corresponding to the appropriate university. R will not try to perform calculations on the row names. However, we still need to eliminate the first column in the data where the names are stored. Try:\n\n# Eliminates first column (containing the row names)\ncollege <- college[,-1]\n# fix(college)\n\nNow you should see that the first data column is Private. Note that another column labeled row.names now appears before the Private column. However, this is not a data column but rather the name that R is giving to each row.\n8. c. i) Use the summary() function to produce a numerical summary of the variables in the data set.\nAnswer:\n\nsummary(college[, 1:5])\n\n   Private               Apps           Accept          Enroll    \n Length:777         Min.   :   81   Min.   :   72   Min.   :  35  \n Class :character   1st Qu.:  776   1st Qu.:  604   1st Qu.: 242  \n Mode  :character   Median : 1558   Median : 1110   Median : 434  \n                    Mean   : 3002   Mean   : 2019   Mean   : 780  \n                    3rd Qu.: 3624   3rd Qu.: 2424   3rd Qu.: 902  \n                    Max.   :48094   Max.   :26330   Max.   :6392  \n   Top10perc    \n Min.   : 1.00  \n 1st Qu.:15.00  \n Median :23.00  \n Mean   :27.56  \n 3rd Qu.:35.00  \n Max.   :96.00  \n\n\n8. c. ii) Use the pairs() function to produce a scatterplot matrix of the 2nd to 10th column or variables of the data. Recall that you can reference the 2nd to 10th column of a matrix A using A[,2:10].\nAnswer:\n\npairs(x = college[,2:10])\n\n\n\n\n8. c. iii) Use the boxplot() function to produce side-by-side boxplots of Outstate versus Private.\nAnswer:\n\nboxplot(Outstate~Private, \n        data = college, \n        xlab = \"Private\", \n        ylab = \"Outstate\")\n\n\n\n\n8. c. iv) Create a new qualitative variable, called Elite, by binning the Top10perc variable. We are going to divide universities into two groups based on whether or not the proportion of students coming from the top 10% of their high school classes exceeds 50%.\n\n# Creating a vector called ELite with only \"No\" entrances amounting the number of college rows\nElite <- rep(\"No\",nrow(college))\n\n# Replacing \"No\" with \"Yes\" if the proportion of students coming from the top 10% of their HS classes exceeds 50%.\nElite[college$Top10perc > 50] <- \"Yes\"\n\n# Encode a vector as a factor\nElite <- as.factor(Elite)\n\n# Add Elite variable to our current dataset \"college\"\ncollege <- data.frame(college, Elite)\n\nUse the summary() function to see how many elite universities there are. Now use the boxplot() function to produce side-by-side boxplots of Outstate versus Elite.\nAnswer:\n\nsummary(college$Elite)\n\n No Yes \n699  78 \n\n\nThere are \\(78\\) elite Universities. The boxplots of Outstate versus Elite-Status are generated as following:\n\nboxplot(Outstate ~ Elite, \n        data = college, xlab=\"Elite\", ylab=\"Outstate\")\n\n\n\n\n8. c. v) Use the hist() function to produce some histograms with differing numbers of bins for a few of the quantitative variables. You may find the command par(mfrow=c(2,2)) useful: it will divide the print window into four regions so that four plots can be made simultaneously. Modifying the arguments to this function will divide the screen in other ways.\nAnswer:\n\npar(mfrow=c(2,2))\nhist(college$Apps,     breaks=50, xlim=c(0,25000), \n     main=\"Apps\")\nhist(college$Enroll,   breaks=25, main=\"Enroll\")\nhist(college$Expend,   breaks=25, main=\"Expend\")\nhist(college$Outstate, main=\"Outstate\")\n\n\n\npar(mfrow=c(1,1))"
  },
  {
    "objectID": "Ch2_Exercises.html#e-xercise-9",
    "href": "Ch2_Exercises.html#e-xercise-9",
    "title": "2  Exercise 7:",
    "section": "2.2 E xercise 9:",
    "text": "2.2 E xercise 9:\nThis exercise involves the Auto data set. Make sure that the missing values have been removed from the data.\n\n# Store data into dataframe college\nAuto <- read.csv(\"DATA/Auto.csv\", header=T, na.strings=\"?\")\n\n# Remove missing values from the data\nAuto <- na.omit(Auto)\n\n# Print first 10 rows of the data\nprint(Auto[c(1:10),])\n\n   mpg cylinders displacement horsepower weight acceleration year origin\n1   18         8          307        130   3504         12.0   70      1\n2   15         8          350        165   3693         11.5   70      1\n3   18         8          318        150   3436         11.0   70      1\n4   16         8          304        150   3433         12.0   70      1\n5   17         8          302        140   3449         10.5   70      1\n6   15         8          429        198   4341         10.0   70      1\n7   14         8          454        220   4354          9.0   70      1\n8   14         8          440        215   4312          8.5   70      1\n9   14         8          455        225   4425         10.0   70      1\n10  15         8          390        190   3850          8.5   70      1\n                        name\n1  chevrolet chevelle malibu\n2          buick skylark 320\n3         plymouth satellite\n4              amc rebel sst\n5                ford torino\n6           ford galaxie 500\n7           chevrolet impala\n8          plymouth fury iii\n9           pontiac catalina\n10        amc ambassador dpl\n\n# Find more info on the variables here: https://rstudio-pubs-static.s3.amazonaws.com/61800_faea93548c6b49cc91cd0c5ef5059894.html\n\n9. a) Which of the predictors are quantitative, and which are qualitative?\nAnswer:\n\n# Summarize dataset\nsummary(Auto)\n\n      mpg          cylinders      displacement     horsepower        weight    \n Min.   : 9.00   Min.   :3.000   Min.   : 68.0   Min.   : 46.0   Min.   :1613  \n 1st Qu.:17.00   1st Qu.:4.000   1st Qu.:105.0   1st Qu.: 75.0   1st Qu.:2225  \n Median :22.75   Median :4.000   Median :151.0   Median : 93.5   Median :2804  \n Mean   :23.45   Mean   :5.472   Mean   :194.4   Mean   :104.5   Mean   :2978  \n 3rd Qu.:29.00   3rd Qu.:8.000   3rd Qu.:275.8   3rd Qu.:126.0   3rd Qu.:3615  \n Max.   :46.60   Max.   :8.000   Max.   :455.0   Max.   :230.0   Max.   :5140  \n  acceleration        year           origin          name          \n Min.   : 8.00   Min.   :70.00   Min.   :1.000   Length:392        \n 1st Qu.:13.78   1st Qu.:73.00   1st Qu.:1.000   Class :character  \n Median :15.50   Median :76.00   Median :1.000   Mode  :character  \n Mean   :15.54   Mean   :75.98   Mean   :1.577                     \n 3rd Qu.:17.02   3rd Qu.:79.00   3rd Qu.:2.000                     \n Max.   :24.80   Max.   :82.00   Max.   :3.000                     \n\n\n\nQuantitative predictors: mpg, cylinders, displacement, horsepower, weight, acceleration, year\nQualitative predictors: name, origin\n\n9. b) What is the range of each quantitative predictor? You can answer this using the range() function.\nAnswer:\n\n# apply the range function to the first seven columns of Auto\nc <- sapply(Auto[, 1:7], range)\n# print to console\nc\n\n      mpg cylinders displacement horsepower weight acceleration year\n[1,]  9.0         3           68         46   1613          8.0   70\n[2,] 46.6         8          455        230   5140         24.8   82\n\n\n9. c) What is the mean and standard deviation of each quantitative predictor?\nAnswer:\n\n# compute mean for the first seven variables and store it in a vector\nmean <- sapply(Auto[,1:7], mean)\n\n# round the values inside the vectors to 2 decimal cases\nmean <- sapply(mean,round,2)\n\n# compute the standard deviation and round it up \nsd <- sapply(Auto[, 1:7], sd)\nsd <- sapply(sd,round,2)\n\n# print both vectors\nmean\n\n         mpg    cylinders displacement   horsepower       weight acceleration \n       23.45         5.47       194.41       104.47      2977.58        15.54 \n        year \n       75.98 \n\nsd\n\n         mpg    cylinders displacement   horsepower       weight acceleration \n        7.81         1.71       104.64        38.49       849.40         2.76 \n        year \n        3.68 \n\n\n9.d) Now remove the 10th through 85th observations. What is the range, mean, and standard deviation of each predictor in the subset of the data that remains?\nAnswer:\n\n# remove observations and store them \nnewAuto = Auto[-(10:85),]\n\n# Re-do exercises 9. b) and 9.c)\n# This time, create an empty Matrix \"Results\" to store the results\nResults <- matrix(NA, nrow = 4, ncol = 7, \n                  dimnames = list(c(\"Mean\", \"SD\", \"Minimum\", \"Maximum\"), \n                                  c(colnames(newAuto[,1:7]))))\n\n# Store the results\nResults[1,] <- sapply(newAuto[, 1:7], mean)\nResults[2,] <- sapply(newAuto[, 1:7], sd)  # Standard Deviation\nResults[3,] <- sapply(newAuto[, 1:7], min)\nResults[4,] <- sapply(newAuto[, 1:7], max)\n\n# Round them\nResults[] <- sapply(Results[],round,2)\n\n# Print the results\n# Results\nprint(Results[,1:6])\n\n          mpg cylinders displacement horsepower  weight acceleration\nMean    24.40      5.37       187.24     100.72 2935.97        15.73\nSD       7.87      1.65        99.68      35.71  811.30         2.69\nMinimum 11.00      3.00        68.00      46.00 1649.00         8.50\nMaximum 46.60      8.00       455.00     230.00 4997.00        24.80\n\n\n9. e) Using the full data set, investigate the predictors graphically, using scatterplots or other tools of your choice. Create some plots highlighting the relationships among the predictors. Comment on your findings.\nAnswer:\n\npairs(Auto[, -9])\n\n\n\n\n\nheavier weight is related with lower mpg and with higher horsepower;\nhigher horsepower correlates with lower acceleration;\nmpg (miles per gallon) mostly increases for newer model years meaning that cars become more efficient over time.\n\n9. f) Suppose that we wish to predict gas mileage (mpg) on the basis of the other variables. Do your plots suggest that any of the other variables might be useful in predicting mpg? Justify your answer.\nAnswer:\nYes. On the one hand, as we can see from the plot above, all of the quantitative variables show some sort of relation (either linear or non-linear) with mpg and hence, they might be useful in predicting mpg. The origin qualitative variable might also be useful in predicting mpg, with cars originated from region 3 being associated with higher mpg. On the other hand, the name predictor has too little observations per name though, so using this as a predictor is likely to result in overfitting the data and will not generalize well."
  },
  {
    "objectID": "Ch2_RLab.html#exercise-7",
    "href": "Ch2_RLab.html#exercise-7",
    "title": "1  Introduction to R",
    "section": "Exercise 7",
    "text": "Exercise 7\nThe table below provides a training data set containing six observations, three predictors, and one qualitative response variable. Suppose we wish to use this data set to make a prediction for \\(Y\\) when \\(X_1 = X_2 = X_3 = 0\\) using K-nearest neighbors.\n\n\n\nObs.\n\\(X_1\\)\n\\(X_2\\)\n\\(X_3\\)\n\\(Y\\)\n\n\n\n\n1\n0\n3\n0\nRed\n\n\n2\n2\n0\n0\nRed\n\n\n3\n0\n1\n3\nRed\n\n\n4\n0\n1\n2\nGreen\n\n\n5\n−1\n0\n1\nGreen\n\n\n6\n1\n1\n1\nRed\n\n\n\n7. a) Compute the Euclidean distance between each observation and the test point, \\(X_1 = X_2 = X_3 = 0\\).\nAnswer:\n\n# Observations\nobs1 <- c( 0, 3, 0)\nobs2 <- c( 2, 0, 0)\nobs3 <- c( 0, 1, 3)\nobs4 <- c( 0, 1, 2)\nobs5 <- c(-1, 0, 1)\nobs6 <- c( 1, 1, 1)\n\n# Test Point\nobs0 <- c(0, 0, 0)\n\n# Create a Vector Dist_vec to store the results\nDist <- numeric(length = 6)\n\n# Compute and store the Euclidean distances\nDist[1] <- (dist1 <- sqrt(sum((obs1-obs0)^2)) )\nDist[2] <- (dist2 <- sqrt(sum((obs2-obs0)^2)) )\nDist[3] <- (dist3 <- sqrt(sum((obs3-obs0)^2)) )\nDist[4] <- (dist4 <- sqrt(sum((obs4-obs0)^2)) )\nDist[5] <- (dist5 <- sqrt(sum((obs5-obs0)^2)) )\nDist[6] <- (dist6 <- sqrt(sum((obs6-obs0)^2)) )\n\n# Print the results\nDist\n\n[1] 3.000000 2.000000 3.162278 2.236068 1.414214 1.732051\n\n\n7. b) What is your prediction with \\(K = 1\\)? Why?\nAnswer: ::: {.cell}\nwhich.min(Dist)\n\n[1] 5\n\n:::\nClosest 1 neighbor is obs5 and thus, our prediction is Green because Green is the \\(Y\\) value associated to obs5.\n7. c) What is your prediction with \\(K = 3\\)? Why?\nAnswer: ::: {.cell}\norder(Dist)[1:3]\n\n[1] 5 6 2\n\n:::\nClosest 3 neighbors are obs5, obs6, obs2 and thus, our prediction is Red because it is the \\(Y\\) value associated to obs2 and obs6 (majority rule).\n7. d) If the Bayes decision boundary in this problem is highly nonlinear, then would we expect the best value for \\(K\\) to be large or small? Why?\nAnswer:\nA large value of K means that the \\(Y\\)-values from a large neighborhood are contributing to the prediction at one chosen \\(X\\)-point. This requires that the neighborhood consists of relatively similar \\(Y\\)-values. However, in the case of a highly nonlinear decision boundary, the neighborhoods of similar \\(Y\\)-values become generally small. Therefore, also \\(K\\) must be chosen relatively small so that we can capture more of the non-linear decision boundary."
  },
  {
    "objectID": "Ch2_RLab.html#e-xercise-8",
    "href": "Ch2_RLab.html#e-xercise-8",
    "title": "1  Introduction to R",
    "section": "1.10 E xercise 8:",
    "text": "1.10 E xercise 8:\nThis exercise relates to the College data set, which can be found in the file College.csv. It contains a number of variables for \\(777\\) different universities and colleges in the US. The variables are:\n\nPrivate : Public/private indicator\nApps : Number of applications received\nAccept : Number of applicants accepted\nEnroll : Number of new students enrolled\nTop10perc : New students from top 10% of high school class\nTop25perc : New students from top 25% of high school class\nF.Undergrad : Number of full-time undergraduates\nP.Undergrad : Number of part-time undergraduates\nOutstate : Out-of-state tuition\nRoom.Board : Room and board costs\nBooks : Estimated book costs\nPersonal : Estimated personal spending\nPhD : Percent of faculty with Ph.D.’s\nTerminal : Percent of faculty with terminal degree\nS.F.Ratio : Student/faculty ratio\nperc.alumni : Percent of alumni who donate\nExpend : Instructional expenditure per student\nGrad.Rate : Graduation rate\n\n8. a) Use the read.csv() function to read the data into R. Call the loaded data college. Make sure that you have the directory set to the correct location for the data.\nAnswer:\n\n# Store data into dataframe college\ncollege <- read.csv(\"DATA/College.csv\")\n\n# Print first 10 rows and 5 collumns of the data\nprint(college[c(1:10),c(1:5)])\n\n                              X Private Apps Accept Enroll\n1  Abilene Christian University     Yes 1660   1232    721\n2            Adelphi University     Yes 2186   1924    512\n3                Adrian College     Yes 1428   1097    336\n4           Agnes Scott College     Yes  417    349    137\n5     Alaska Pacific University     Yes  193    146     55\n6             Albertson College     Yes  587    479    158\n7       Albertus Magnus College     Yes  353    340    103\n8                Albion College     Yes 1899   1720    489\n9              Albright College     Yes 1038    839    227\n10    Alderson-Broaddus College     Yes  582    498    172\n\n\n8. b) Look at the data using the fix() function.\nAnswer:\nYou should notice that the first column is just the name of each university. We don’t really want R to treat this as data. However, it may be handy to have these names for later. Try the following commands:\n\n# Store row names\nrownames(college) <- college[,1]\n\n# pops up a window for data visualization\n# fix(college)\n\nYou should see that there is now a row.names column with the name of each university recorded. This means that R has given each row a name corresponding to the appropriate university. R will not try to perform calculations on the row names. However, we still need to eliminate the first column in the data where the names are stored. Try:\n\n# Eliminates first column (containing the row names)\ncollege <- college[,-1]\n# fix(college)\n\nNow you should see that the first data column is Private. Note that another column labeled row.names now appears before the Private column. However, this is not a data column but rather the name that R is giving to each row.\n8. c. i) Use the summary() function to produce a numerical summary of the variables in the data set.\nAnswer:\n\nsummary(college[, 1:5])\n\n   Private               Apps           Accept          Enroll    \n Length:777         Min.   :   81   Min.   :   72   Min.   :  35  \n Class :character   1st Qu.:  776   1st Qu.:  604   1st Qu.: 242  \n Mode  :character   Median : 1558   Median : 1110   Median : 434  \n                    Mean   : 3002   Mean   : 2019   Mean   : 780  \n                    3rd Qu.: 3624   3rd Qu.: 2424   3rd Qu.: 902  \n                    Max.   :48094   Max.   :26330   Max.   :6392  \n   Top10perc    \n Min.   : 1.00  \n 1st Qu.:15.00  \n Median :23.00  \n Mean   :27.56  \n 3rd Qu.:35.00  \n Max.   :96.00  \n\n\n8. c. ii) Use the pairs() function to produce a scatterplot matrix of the 2nd to 10th column or variables of the data. Recall that you can reference the 2nd to 10th column of a matrix A using A[,2:10].\nAnswer:\n\npairs(x = college[,2:10])\n\n\n\n\n8. c. iii) Use the boxplot() function to produce side-by-side boxplots of Outstate versus Private.\nAnswer:\n\nboxplot(Outstate~Private, \n        data = college, \n        xlab = \"Private\", \n        ylab = \"Outstate\")\n\n\n\n\n8. c. iv) Create a new qualitative variable, called Elite, by binning the Top10perc variable. We are going to divide universities into two groups based on whether or not the proportion of students coming from the top 10% of their high school classes exceeds 50%.\n\n# Creating a vector called ELite with only \"No\" entrances amounting the number of college rows\nElite <- rep(\"No\",nrow(college))\n\n# Replacing \"No\" with \"Yes\" if the proportion of students coming from the top 10% of their HS classes exceeds 50%.\nElite[college$Top10perc > 50] <- \"Yes\"\n\n# Encode a vector as a factor\nElite <- as.factor(Elite)\n\n# Add Elite variable to our current dataset \"college\"\ncollege <- data.frame(college, Elite)\n\nUse the summary() function to see how many elite universities there are. Now use the boxplot() function to produce side-by-side boxplots of Outstate versus Elite.\nAnswer:\n\nsummary(college$Elite)\n\n No Yes \n699  78 \n\n\nThere are \\(78\\) elite Universities. The boxplots of Outstate versus Elite-Status are generated as following:\n\nboxplot(Outstate ~ Elite, \n        data = college, xlab=\"Elite\", ylab=\"Outstate\")\n\n\n\n\n8. c. v) Use the hist() function to produce some histograms with differing numbers of bins for a few of the quantitative variables. You may find the command par(mfrow=c(2,2)) useful: it will divide the print window into four regions so that four plots can be made simultaneously. Modifying the arguments to this function will divide the screen in other ways.\nAnswer:\n\npar(mfrow=c(2,2))\nhist(college$Apps,     breaks=50, xlim=c(0,25000), \n     main=\"Apps\")\nhist(college$Enroll,   breaks=25, main=\"Enroll\")\nhist(college$Expend,   breaks=25, main=\"Expend\")\nhist(college$Outstate, main=\"Outstate\")\n\n\n\npar(mfrow=c(1,1))"
  },
  {
    "objectID": "Ch2_RLab.html#e-xercise-9",
    "href": "Ch2_RLab.html#e-xercise-9",
    "title": "1  Introduction to R",
    "section": "1.11 E xercise 9:",
    "text": "1.11 E xercise 9:\nThis exercise involves the Auto data set. Make sure that the missing values have been removed from the data.\n\n# Store data into dataframe college\nAuto <- read.csv(\"DATA/Auto.csv\", header=T, na.strings=\"?\")\n\n# Remove missing values from the data\nAuto <- na.omit(Auto)\n\n# Print first 10 rows of the data\nprint(Auto[c(1:10),])\n\n   mpg cylinders displacement horsepower weight acceleration year origin\n1   18         8          307        130   3504         12.0   70      1\n2   15         8          350        165   3693         11.5   70      1\n3   18         8          318        150   3436         11.0   70      1\n4   16         8          304        150   3433         12.0   70      1\n5   17         8          302        140   3449         10.5   70      1\n6   15         8          429        198   4341         10.0   70      1\n7   14         8          454        220   4354          9.0   70      1\n8   14         8          440        215   4312          8.5   70      1\n9   14         8          455        225   4425         10.0   70      1\n10  15         8          390        190   3850          8.5   70      1\n                        name\n1  chevrolet chevelle malibu\n2          buick skylark 320\n3         plymouth satellite\n4              amc rebel sst\n5                ford torino\n6           ford galaxie 500\n7           chevrolet impala\n8          plymouth fury iii\n9           pontiac catalina\n10        amc ambassador dpl\n\n# Find more info on the variables here: https://rstudio-pubs-static.s3.amazonaws.com/61800_faea93548c6b49cc91cd0c5ef5059894.html\n\n9. a) Which of the predictors are quantitative, and which are qualitative?\nAnswer:\n\n# Summarize dataset\nsummary(Auto)\n\n      mpg          cylinders      displacement     horsepower        weight    \n Min.   : 9.00   Min.   :3.000   Min.   : 68.0   Min.   : 46.0   Min.   :1613  \n 1st Qu.:17.00   1st Qu.:4.000   1st Qu.:105.0   1st Qu.: 75.0   1st Qu.:2225  \n Median :22.75   Median :4.000   Median :151.0   Median : 93.5   Median :2804  \n Mean   :23.45   Mean   :5.472   Mean   :194.4   Mean   :104.5   Mean   :2978  \n 3rd Qu.:29.00   3rd Qu.:8.000   3rd Qu.:275.8   3rd Qu.:126.0   3rd Qu.:3615  \n Max.   :46.60   Max.   :8.000   Max.   :455.0   Max.   :230.0   Max.   :5140  \n  acceleration        year           origin          name          \n Min.   : 8.00   Min.   :70.00   Min.   :1.000   Length:392        \n 1st Qu.:13.78   1st Qu.:73.00   1st Qu.:1.000   Class :character  \n Median :15.50   Median :76.00   Median :1.000   Mode  :character  \n Mean   :15.54   Mean   :75.98   Mean   :1.577                     \n 3rd Qu.:17.02   3rd Qu.:79.00   3rd Qu.:2.000                     \n Max.   :24.80   Max.   :82.00   Max.   :3.000                     \n\n\n\nQuantitative predictors: mpg, cylinders, displacement, horsepower, weight, acceleration, year\nQualitative predictors: name, origin\n\n9. b) What is the range of each quantitative predictor? You can answer this using the range() function.\nAnswer:\n\n# apply the range function to the first seven columns of Auto\nc <- sapply(Auto[, 1:7], range)\n# print to console\nc\n\n      mpg cylinders displacement horsepower weight acceleration year\n[1,]  9.0         3           68         46   1613          8.0   70\n[2,] 46.6         8          455        230   5140         24.8   82\n\n\n9. c) What is the mean and standard deviation of each quantitative predictor?\nAnswer:\n\n# compute mean for the first seven variables and store it in a vector\nmean <- sapply(Auto[,1:7], mean)\n\n# round the values inside the vectors to 2 decimal cases\nmean <- sapply(mean,round,2)\n\n# compute the standard deviation and round it up \nsd <- sapply(Auto[, 1:7], sd)\nsd <- sapply(sd,round,2)\n\n# print both vectors\nmean\n\n         mpg    cylinders displacement   horsepower       weight acceleration \n       23.45         5.47       194.41       104.47      2977.58        15.54 \n        year \n       75.98 \n\nsd\n\n         mpg    cylinders displacement   horsepower       weight acceleration \n        7.81         1.71       104.64        38.49       849.40         2.76 \n        year \n        3.68 \n\n\n9.d) Now remove the 10th through 85th observations. What is the range, mean, and standard deviation of each predictor in the subset of the data that remains?\nAnswer:\n\n# remove observations and store them \nnewAuto = Auto[-(10:85),]\n\n# Re-do exercises 9. b) and 9.c)\n# This time, create an empty Matrix \"Results\" to store the results\nResults <- matrix(NA, nrow = 4, ncol = 7, \n                  dimnames = list(c(\"Mean\", \"SD\", \"Minimum\", \"Maximum\"), \n                                  c(colnames(newAuto[,1:7]))))\n\n# Store the results\nResults[1,] <- sapply(newAuto[, 1:7], mean)\nResults[2,] <- sapply(newAuto[, 1:7], sd)  # Standard Deviation\nResults[3,] <- sapply(newAuto[, 1:7], min)\nResults[4,] <- sapply(newAuto[, 1:7], max)\n\n# Round them\nResults[] <- sapply(Results[],round,2)\n\n# Print the results\n# Results\nprint(Results[,1:6])\n\n          mpg cylinders displacement horsepower  weight acceleration\nMean    24.40      5.37       187.24     100.72 2935.97        15.73\nSD       7.87      1.65        99.68      35.71  811.30         2.69\nMinimum 11.00      3.00        68.00      46.00 1649.00         8.50\nMaximum 46.60      8.00       455.00     230.00 4997.00        24.80\n\n\n9. e) Using the full data set, investigate the predictors graphically, using scatterplots or other tools of your choice. Create some plots highlighting the relationships among the predictors. Comment on your findings.\nAnswer:\n\npairs(Auto[, -9])\n\n\n\n\n\nheavier weight is related with lower mpg and with higher horsepower;\nhigher horsepower correlates with lower acceleration;\nmpg (miles per gallon) mostly increases for newer model years meaning that cars become more efficient over time.\n\n9. f) Suppose that we wish to predict gas mileage (mpg) on the basis of the other variables. Do your plots suggest that any of the other variables might be useful in predicting mpg? Justify your answer.\nAnswer:\nYes. On the one hand, as we can see from the plot above, all of the quantitative variables show some sort of relation (either linear or non-linear) with mpg and hence, they might be useful in predicting mpg. The origin qualitative variable might also be useful in predicting mpg, with cars originated from region 3 being associated with higher mpg. On the other hand, the name predictor has too little observations per name though, so using this as a predictor is likely to result in overfitting the data and will not generalize well."
  },
  {
    "objectID": "Ch2_RLab.html#exercise-8",
    "href": "Ch2_RLab.html#exercise-8",
    "title": "1  Introduction to R",
    "section": "Exercise 8:",
    "text": "Exercise 8:\nThis exercise relates to the College data set, which can be found in the file College.csv. It contains a number of variables for \\(777\\) different universities and colleges in the US. The variables are:\n\nPrivate : Public/private indicator\nApps : Number of applications received\nAccept : Number of applicants accepted\nEnroll : Number of new students enrolled\nTop10perc : New students from top 10% of high school class\nTop25perc : New students from top 25% of high school class\nF.Undergrad : Number of full-time undergraduates\nP.Undergrad : Number of part-time undergraduates\nOutstate : Out-of-state tuition\nRoom.Board : Room and board costs\nBooks : Estimated book costs\nPersonal : Estimated personal spending\nPhD : Percent of faculty with Ph.D.’s\nTerminal : Percent of faculty with terminal degree\nS.F.Ratio : Student/faculty ratio\nperc.alumni : Percent of alumni who donate\nExpend : Instructional expenditure per student\nGrad.Rate : Graduation rate\n\n8. a) Use the read.csv() function to read the data into R. Call the loaded data college. Make sure that you have the directory set to the correct location for the data.\nAnswer:\n\n# Store data into dataframe college\ncollege <- read.csv(\"DATA/College.csv\")\n\n# Print first 10 rows and 5 collumns of the data\nprint(college[c(1:10),c(1:5)])\n\n                              X Private Apps Accept Enroll\n1  Abilene Christian University     Yes 1660   1232    721\n2            Adelphi University     Yes 2186   1924    512\n3                Adrian College     Yes 1428   1097    336\n4           Agnes Scott College     Yes  417    349    137\n5     Alaska Pacific University     Yes  193    146     55\n6             Albertson College     Yes  587    479    158\n7       Albertus Magnus College     Yes  353    340    103\n8                Albion College     Yes 1899   1720    489\n9              Albright College     Yes 1038    839    227\n10    Alderson-Broaddus College     Yes  582    498    172\n\n\n8. b) Look at the data using the fix() function.\nAnswer:\nYou should notice that the first column is just the name of each university. We don’t really want R to treat this as data. However, it may be handy to have these names for later. Try the following commands:\n\n# Store row names\nrownames(college) <- college[,1]\n\n# pops up a window for data visualization\n# fix(college)\n\nYou should see that there is now a row.names column with the name of each university recorded. This means that R has given each row a name corresponding to the appropriate university. R will not try to perform calculations on the row names. However, we still need to eliminate the first column in the data where the names are stored. Try:\n\n# Eliminates first column (containing the row names)\ncollege <- college[,-1]\n# fix(college)\n\nNow you should see that the first data column is Private. Note that another column labeled row.names now appears before the Private column. However, this is not a data column but rather the name that R is giving to each row.\n8. c. i) Use the summary() function to produce a numerical summary of the variables in the data set.\nAnswer:\n\nsummary(college[, 1:5])\n\n   Private               Apps           Accept          Enroll    \n Length:777         Min.   :   81   Min.   :   72   Min.   :  35  \n Class :character   1st Qu.:  776   1st Qu.:  604   1st Qu.: 242  \n Mode  :character   Median : 1558   Median : 1110   Median : 434  \n                    Mean   : 3002   Mean   : 2019   Mean   : 780  \n                    3rd Qu.: 3624   3rd Qu.: 2424   3rd Qu.: 902  \n                    Max.   :48094   Max.   :26330   Max.   :6392  \n   Top10perc    \n Min.   : 1.00  \n 1st Qu.:15.00  \n Median :23.00  \n Mean   :27.56  \n 3rd Qu.:35.00  \n Max.   :96.00  \n\n\n8. c. ii) Use the pairs() function to produce a scatterplot matrix of the 2nd to 10th column or variables of the data. Recall that you can reference the 2nd to 10th column of a matrix A using A[,2:10].\nAnswer:\n\npairs(x = college[,2:10])\n\n\n\n\n8. c. iii) Use the boxplot() function to produce side-by-side boxplots of Outstate versus Private.\nAnswer:\n\nboxplot(Outstate~Private, \n        data = college, \n        xlab = \"Private\", \n        ylab = \"Outstate\")\n\n\n\n\n8. c. iv) Create a new qualitative variable, called Elite, by binning the Top10perc variable. We are going to divide universities into two groups based on whether or not the proportion of students coming from the top 10% of their high school classes exceeds 50%.\n\n# Creating a vector called ELite with only \"No\" entrances amounting the number of college rows\nElite <- rep(\"No\",nrow(college))\n\n# Replacing \"No\" with \"Yes\" if the proportion of students coming from the top 10% of their HS classes exceeds 50%.\nElite[college$Top10perc > 50] <- \"Yes\"\n\n# Encode a vector as a factor\nElite <- as.factor(Elite)\n\n# Add Elite variable to our current dataset \"college\"\ncollege <- data.frame(college, Elite)\n\nUse the summary() function to see how many elite universities there are. Now use the boxplot() function to produce side-by-side boxplots of Outstate versus Elite.\nAnswer:\n\nsummary(college$Elite)\n\n No Yes \n699  78 \n\n\nThere are \\(78\\) elite Universities. The boxplots of Outstate versus Elite-Status are generated as following:\n\nboxplot(Outstate ~ Elite, \n        data = college, xlab=\"Elite\", ylab=\"Outstate\")\n\n\n\n\n8. c. v) Use the hist() function to produce some histograms with differing numbers of bins for a few of the quantitative variables. You may find the command par(mfrow=c(2,2)) useful: it will divide the print window into four regions so that four plots can be made simultaneously. Modifying the arguments to this function will divide the screen in other ways.\nAnswer:\n\npar(mfrow=c(2,2))\nhist(college$Apps,     breaks=50, xlim=c(0,25000), \n     main=\"Apps\")\nhist(college$Enroll,   breaks=25, main=\"Enroll\")\nhist(college$Expend,   breaks=25, main=\"Expend\")\nhist(college$Outstate, main=\"Outstate\")\n\n\n\npar(mfrow=c(1,1))"
  },
  {
    "objectID": "Ch2_RLab.html#exercise-9",
    "href": "Ch2_RLab.html#exercise-9",
    "title": "1  Introduction to R",
    "section": "Exercise 9:",
    "text": "Exercise 9:\nThis exercise involves the Auto data set. Make sure that the missing values have been removed from the data.\n\n# Store data into dataframe college\nAuto <- read.csv(\"DATA/Auto.csv\", header=T, na.strings=\"?\")\n\n# Remove missing values from the data\nAuto <- na.omit(Auto)\n\n# Print first 10 rows of the data\nprint(Auto[c(1:10),])\n\n   mpg cylinders displacement horsepower weight acceleration year origin\n1   18         8          307        130   3504         12.0   70      1\n2   15         8          350        165   3693         11.5   70      1\n3   18         8          318        150   3436         11.0   70      1\n4   16         8          304        150   3433         12.0   70      1\n5   17         8          302        140   3449         10.5   70      1\n6   15         8          429        198   4341         10.0   70      1\n7   14         8          454        220   4354          9.0   70      1\n8   14         8          440        215   4312          8.5   70      1\n9   14         8          455        225   4425         10.0   70      1\n10  15         8          390        190   3850          8.5   70      1\n                        name\n1  chevrolet chevelle malibu\n2          buick skylark 320\n3         plymouth satellite\n4              amc rebel sst\n5                ford torino\n6           ford galaxie 500\n7           chevrolet impala\n8          plymouth fury iii\n9           pontiac catalina\n10        amc ambassador dpl\n\n# Find more info on the variables here: https://rstudio-pubs-static.s3.amazonaws.com/61800_faea93548c6b49cc91cd0c5ef5059894.html\n\n9. a) Which of the predictors are quantitative, and which are qualitative?\nAnswer:\n\n# Summarize dataset\nsummary(Auto)\n\n      mpg          cylinders      displacement     horsepower        weight    \n Min.   : 9.00   Min.   :3.000   Min.   : 68.0   Min.   : 46.0   Min.   :1613  \n 1st Qu.:17.00   1st Qu.:4.000   1st Qu.:105.0   1st Qu.: 75.0   1st Qu.:2225  \n Median :22.75   Median :4.000   Median :151.0   Median : 93.5   Median :2804  \n Mean   :23.45   Mean   :5.472   Mean   :194.4   Mean   :104.5   Mean   :2978  \n 3rd Qu.:29.00   3rd Qu.:8.000   3rd Qu.:275.8   3rd Qu.:126.0   3rd Qu.:3615  \n Max.   :46.60   Max.   :8.000   Max.   :455.0   Max.   :230.0   Max.   :5140  \n  acceleration        year           origin          name          \n Min.   : 8.00   Min.   :70.00   Min.   :1.000   Length:392        \n 1st Qu.:13.78   1st Qu.:73.00   1st Qu.:1.000   Class :character  \n Median :15.50   Median :76.00   Median :1.000   Mode  :character  \n Mean   :15.54   Mean   :75.98   Mean   :1.577                     \n 3rd Qu.:17.02   3rd Qu.:79.00   3rd Qu.:2.000                     \n Max.   :24.80   Max.   :82.00   Max.   :3.000                     \n\n\n\nQuantitative predictors: mpg, cylinders, displacement, horsepower, weight, acceleration, year\nQualitative predictors: name, origin\n\n9. b) What is the range of each quantitative predictor? You can answer this using the range() function.\nAnswer:\n\n# apply the range function to the first seven columns of Auto\nc <- sapply(Auto[, 1:7], range)\n# print to console\nc\n\n      mpg cylinders displacement horsepower weight acceleration year\n[1,]  9.0         3           68         46   1613          8.0   70\n[2,] 46.6         8          455        230   5140         24.8   82\n\n\n9. c) What is the mean and standard deviation of each quantitative predictor?\nAnswer:\n\n# compute mean for the first seven variables and store it in a vector\nmean <- sapply(Auto[,1:7], mean)\n\n# round the values inside the vectors to 2 decimal cases\nmean <- sapply(mean,round,2)\n\n# compute the standard deviation and round it up \nsd <- sapply(Auto[, 1:7], sd)\nsd <- sapply(sd,round,2)\n\n# print both vectors\nmean\n\n         mpg    cylinders displacement   horsepower       weight acceleration \n       23.45         5.47       194.41       104.47      2977.58        15.54 \n        year \n       75.98 \n\nsd\n\n         mpg    cylinders displacement   horsepower       weight acceleration \n        7.81         1.71       104.64        38.49       849.40         2.76 \n        year \n        3.68 \n\n\n9.d) Now remove the 10th through 85th observations. What is the range, mean, and standard deviation of each predictor in the subset of the data that remains?\nAnswer:\n\n# remove observations and store them \nnewAuto = Auto[-(10:85),]\n\n# Re-do exercises 9. b) and 9.c)\n# This time, create an empty Matrix \"Results\" to store the results\nResults <- matrix(NA, nrow = 4, ncol = 7, \n                  dimnames = list(c(\"Mean\", \"SD\", \"Minimum\", \"Maximum\"), \n                                  c(colnames(newAuto[,1:7]))))\n\n# Store the results\nResults[1,] <- sapply(newAuto[, 1:7], mean)\nResults[2,] <- sapply(newAuto[, 1:7], sd)  # Standard Deviation\nResults[3,] <- sapply(newAuto[, 1:7], min)\nResults[4,] <- sapply(newAuto[, 1:7], max)\n\n# Round them\nResults[] <- sapply(Results[],round,2)\n\n# Print the results\n# Results\nprint(Results[,1:6])\n\n          mpg cylinders displacement horsepower  weight acceleration\nMean    24.40      5.37       187.24     100.72 2935.97        15.73\nSD       7.87      1.65        99.68      35.71  811.30         2.69\nMinimum 11.00      3.00        68.00      46.00 1649.00         8.50\nMaximum 46.60      8.00       455.00     230.00 4997.00        24.80\n\n\n9. e) Using the full data set, investigate the predictors graphically, using scatterplots or other tools of your choice. Create some plots highlighting the relationships among the predictors. Comment on your findings.\nAnswer:\n\npairs(Auto[, -9])\n\n\n\n\n\nheavier weight is related with lower mpg and with higher horsepower;\nhigher horsepower correlates with lower acceleration;\nmpg (miles per gallon) mostly increases for newer model years meaning that cars become more efficient over time.\n\n9. f) Suppose that we wish to predict gas mileage (mpg) on the basis of the other variables. Do your plots suggest that any of the other variables might be useful in predicting mpg? Justify your answer.\nAnswer:\nYes. On the one hand, as we can see from the plot above, all of the quantitative variables show some sort of relation (either linear or non-linear) with mpg and hence, they might be useful in predicting mpg. The origin qualitative variable might also be useful in predicting mpg, with cars originated from region 3 being associated with higher mpg. On the other hand, the name predictor has too little observations per name though, so using this as a predictor is likely to result in overfitting the data and will not generalize well."
  },
  {
    "objectID": "Ch2_RLab.html#exercises",
    "href": "Ch2_RLab.html#exercises",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "2.9 Exercises",
    "text": "2.9 Exercises\nPrepare the following exercises of Chapter 2 in our course textbook ISLR:\n\nExercise 7\nExercise 8\nExercise 9"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computer-Aided Statistical Analysis B.Sc.",
    "section": "",
    "text": "Day \n    Time \n    Lecture Hall \n  \n \n\n  \n    Monday \n    12:15-13:45 \n    Jur / Hörsaal K \n  \n  \n    Wednesday \n    16:15-17:45 \n    Jur / Hörsaal K \n  \n\n\n\n\n\n\n\n\n\nCourse Textbook (ISLR):\n\nAn Introduction to Statistical Learning (2nd Edition), by Gareth James, Daniela Witten, Trevor Hastie, and Robert Tibshirani\nThe pdf-Version of the textbook ISLR can be downloaded for free: Free Book\n\n\neWhiteboard for the lecture notes.\nThis online script\n\nThe above links to the lecture materials can also be found at eCampus"
  },
  {
    "objectID": "Ch3_RLab.html",
    "href": "Ch3_RLab.html",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "",
    "text": "The library() function is used to load libraries, or groups of functions and data sets that are not included in the base R distribution. Basic functions that perform least squares linear regression and other simple analyses come standard with the base distribution, but more exotic functions require additional libraries. Here we load the MASS package, which is a very large collection of data sets and functions. We also load the ISLR2 package, which includes the data sets associated with this book.\n\nsuppressPackageStartupMessages(library(MASS))\nsuppressPackageStartupMessages(library(ISLR2))\n\nIf you receive an error message when loading any of these libraries, it likely indicates that the corresponding library has not yet been installed on your system. Some libraries, such as MASS, come with R and do not need to be separately installed on your computer. However, other packages, such as ISLR2, must be downloaded the first time they are used. This can be done directly from within R. For example, on a Windows system, select the Install package option under the Packages tab. After you select any mirror site, a list of available packages will appear. Simply select the package you wish to install and R will automatically download the package. Alternatively, this can be done at the R command line via install.packages(\"ISLR2\"). This installation only needs to be done the first time you use a package. However, the library() function must be called within each R session."
  },
  {
    "objectID": "Ch3_RLab.html#variance-inflation-factors",
    "href": "Ch3_RLab.html#variance-inflation-factors",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "5.1 Variance inflation factors",
    "text": "5.1 Variance inflation factors\nPotential multicollinearity problems, can be detected using variance inflation factors \\[\n\\operatorname{VIF}\\left(\\hat{\\beta}_{j}\\right)=\\frac{1}{1-R_{X_{j} \\mid X_{-j}}^{2}}\n\\] VIF-values close to 1 are indicating that the \\(j\\)th predictor is orthogonal to the space spanned by the other predictors (i.e. the other predictors, \\(X_{-j}\\) cannot explain the \\(j\\)th predictor \\(X_j\\)). Large VIF-values \\(\\gg 1\\) are indicating that there may be an multicollinearity problem with the \\(j\\)th predictor.\nIn order to compute the variance inflation factors, we can use the function vif() of the package .\n\nlibrary(\"car\")\n\nLoading required package: carData\n\nvif_vec <- vif(lm.fit)\nvif_vec[order(vif_vec)]\n\n    chas    black     crim  ptratio       rm       zn    lstat      age \n1.073995 1.348521 1.792192 1.799084 1.933744 2.298758 2.941491 3.100826 \n     dis    indus      nox      rad      tax \n3.955945 3.991596 4.393720 7.484496 9.008554"
  },
  {
    "objectID": "Ch3_RLab.html#formula-ticks-for-working-with-lm",
    "href": "Ch3_RLab.html#formula-ticks-for-working-with-lm",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "5.2 Formula-Ticks for working with lm()",
    "text": "5.2 Formula-Ticks for working with lm()\nA short-cut notation for a regression on all predictor variables in the data except on the age is the following\n\nlm.fit1 <- lm(medv ~ . -age, data = Boston)\nsummary(lm.fit1)\n\nAlternatively, the update() function can be used based on the above computed lm.fit object.\n\nlm.fit1 <- update(lm.fit, ~.-age)"
  },
  {
    "objectID": "Ch3_RLab.html#simple-linear-regression",
    "href": "Ch3_RLab.html#simple-linear-regression",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "3.2 Simple Linear Regression",
    "text": "3.2 Simple Linear Regression\nThe ISLR2 library contains the Boston data set, which records medv (median house value) for \\(506\\) census tracts in Boston. We will seek to predict medv using \\(12\\) predictors such as rmvar (average number of rooms per house), age (average age of houses), and lstat (percent of households with low socioeconomic status).\n\nhead(Boston)\n\n     crim zn indus chas   nox    rm  age    dis rad tax ptratio lstat medv\n1 0.00632 18  2.31    0 0.538 6.575 65.2 4.0900   1 296    15.3  4.98 24.0\n2 0.02731  0  7.07    0 0.469 6.421 78.9 4.9671   2 242    17.8  9.14 21.6\n3 0.02729  0  7.07    0 0.469 7.185 61.1 4.9671   2 242    17.8  4.03 34.7\n4 0.03237  0  2.18    0 0.458 6.998 45.8 6.0622   3 222    18.7  2.94 33.4\n5 0.06905  0  2.18    0 0.458 7.147 54.2 6.0622   3 222    18.7  5.33 36.2\n6 0.02985  0  2.18    0 0.458 6.430 58.7 6.0622   3 222    18.7  5.21 28.7\n\n\nTo find out more about the data set, we can type ?Boston.\nWe will start by using the lm() function to fit a simple linear regression model, with medv as the response and lstat as the predictor. The basic syntax is lm(y ~ x, data), where y is the response, x is the predictor, and data is the data set in which these two variables are kept.\n\nlm.fit <- lm(medv ~ lstat)\n\nError in eval(predvars, data, env): object 'medv' not found\n\n\nThe command causes an error because R does not know where to find the variables medv and lstat. The next line tells R that the variables are in Boston. If we attach Boston, the first line works fine because R now recognizes the variables.\n\nlm.fit <- lm(medv ~ lstat, data = Boston)\nattach(Boston)\nlm.fit <- lm(medv ~ lstat)\n\nIf we type lm.fit, some basic information about the model is output. For more detailed information, we use summary(lm.fit). This gives us \\(p\\)-values and standard errors for the coefficients, as well as the \\(R^2\\) statistic and \\(F\\)-statistic for the model.\n\nlm.fit\n\n\nCall:\nlm(formula = medv ~ lstat)\n\nCoefficients:\n(Intercept)        lstat  \n      34.55        -0.95  \n\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ lstat)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.168  -3.990  -1.318   2.034  24.500 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 34.55384    0.56263   61.41   <2e-16 ***\nlstat       -0.95005    0.03873  -24.53   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.216 on 504 degrees of freedom\nMultiple R-squared:  0.5441,    Adjusted R-squared:  0.5432 \nF-statistic: 601.6 on 1 and 504 DF,  p-value: < 2.2e-16\n\n\nWe can use the names() function in order to find out what other pieces of information are stored in lm.fit. Although we can extract these quantities by name—e.g. lm.fit$coefficients—it is safer to use the extractor functions like coef() to access them.\n\nnames(lm.fit)\n\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n\ncoef(lm.fit)\n\n(Intercept)       lstat \n 34.5538409  -0.9500494 \n\n\nIn order to obtain a confidence interval for the coefficient estimates, we can use the confint() command. %Type confint(lm.fit) at the command line to obtain the confidence intervals.\n\nconfint(lm.fit)\n\n                2.5 %     97.5 %\n(Intercept) 33.448457 35.6592247\nlstat       -1.026148 -0.8739505\n\n\nThe predict() function can be used to produce confidence intervals and prediction intervals for the prediction of medv for a given value of lstat.\n\npredict(lm.fit, data.frame(lstat = (c(5, 10, 15))),\n    interval = \"confidence\")\n\n       fit      lwr      upr\n1 29.80359 29.00741 30.59978\n2 25.05335 24.47413 25.63256\n3 20.30310 19.73159 20.87461\n\npredict(lm.fit, data.frame(lstat = (c(5, 10, 15))),\n    interval = \"prediction\")\n\n       fit       lwr      upr\n1 29.80359 17.565675 42.04151\n2 25.05335 12.827626 37.27907\n3 20.30310  8.077742 32.52846\n\n\nFor instance, the 95,% confidence interval associated with a lstat value of 10 is \\((24.47, 25.63)\\), and the 95,% prediction interval is \\((12.828, 37.28)\\). As expected, the confidence and prediction intervals are centered around the same point (a predicted value of \\(25.05\\) for medv when lstat equals 10), but the latter are substantially wider.\nWe will now plot medv and lstat along with the least squares regression line using the plot() and abline() functions.\n\nplot(lstat, medv)\nabline(lm.fit)\n\n\n\n\nThere is some evidence for non-linearity in the relationship between lstat and medv. We will explore this issue later in this lab.\nThe abline() function can be used to draw any line, not just the least squares regression line. To draw a line with intercept a and slope b, we type abline(a, b). Below we experiment with some additional settings for plotting lines and points. The lwd = 3 command causes the width of the regression line to be increased by a factor of 3; this works for the plot() and lines() functions also. We can also use the pch option to create different plotting symbols.\n\nplot(lstat, medv)\nabline(lm.fit, lwd = 3)\nabline(lm.fit, lwd = 3, col = \"red\")\n\n\n\nplot(lstat, medv, col = \"red\")\n\n\n\nplot(lstat, medv, pch = 20)\n\n\n\nplot(lstat, medv, pch = \"+\")\n\n\n\nplot(1:20, 1:20, pch = 1:20)\n\n\n\n\nNext we examine some diagnostic plots, several of which were discussed in Section 3.3.3. Four diagnostic plots are automatically produced by applying the plot() function directly to the output from lm(). In general, this command will produce one plot at a time, and hitting Enter will generate the next plot. However, it is often convenient to view all four plots together. We can achieve this by using the par() and mfrow() functions, which tell R to split the display screen into separate panels so that multiple plots can be viewed simultaneously. For example, par(mfrow = c(2, 2)) divides the plotting region into a \\(2 \\times 2\\) grid of panels.\n\npar(mfrow = c(2, 2))\nplot(lm.fit)\n\n\n\n\nAlternatively, we can compute the residuals from a linear regression fit using the residuals() function. The function rstudent() will return the studentized residuals, and we can use this function to plot the residuals against the fitted values.\n\nplot(predict(lm.fit), residuals(lm.fit))\n\n\n\nplot(predict(lm.fit), rstudent(lm.fit))\n\n\n\n\nOn the basis of the residual plots, there is some evidence of non-linearity. Leverage statistics can be computed for any number of predictors using the hatvalues() function.\n\nplot(hatvalues(lm.fit))\n\n\n\nwhich.max(hatvalues(lm.fit))\n\n375 \n375 \n\n\nThe which.max() function identifies the index of the largest element of a vector. In this case, it tells us which observation has the largest leverage statistic."
  },
  {
    "objectID": "Ch3_RLab.html#multiple-linear-regression",
    "href": "Ch3_RLab.html#multiple-linear-regression",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "3.3 Multiple Linear Regression",
    "text": "3.3 Multiple Linear Regression\nIn order to fit a multiple linear regression model using least squares, we again use the lm() function. The syntax lm(y ~ x1 + x2 + x3) is used to fit a model with three predictors, x1, x2, and x3. The summary() function now outputs the regression coefficients for all the predictors.\n\nlm.fit <- lm(medv ~ lstat + age, data = Boston)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ lstat + age, data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.981  -3.978  -1.283   1.968  23.158 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 33.22276    0.73085  45.458  < 2e-16 ***\nlstat       -1.03207    0.04819 -21.416  < 2e-16 ***\nage          0.03454    0.01223   2.826  0.00491 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.173 on 503 degrees of freedom\nMultiple R-squared:  0.5513,    Adjusted R-squared:  0.5495 \nF-statistic:   309 on 2 and 503 DF,  p-value: < 2.2e-16\n\n\nThe Boston data set contains 12 variables, and so it would be cumbersome to have to type all of these in order to perform a regression using all of the predictors. Instead, we can use the following short-hand:\n\nlm.fit <- lm(medv ~ ., data = Boston)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ ., data = Boston)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.1304  -2.7673  -0.5814   1.9414  26.2526 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  41.617270   4.936039   8.431 3.79e-16 ***\ncrim         -0.121389   0.033000  -3.678 0.000261 ***\nzn            0.046963   0.013879   3.384 0.000772 ***\nindus         0.013468   0.062145   0.217 0.828520    \nchas          2.839993   0.870007   3.264 0.001173 ** \nnox         -18.758022   3.851355  -4.870 1.50e-06 ***\nrm            3.658119   0.420246   8.705  < 2e-16 ***\nage           0.003611   0.013329   0.271 0.786595    \ndis          -1.490754   0.201623  -7.394 6.17e-13 ***\nrad           0.289405   0.066908   4.325 1.84e-05 ***\ntax          -0.012682   0.003801  -3.337 0.000912 ***\nptratio      -0.937533   0.132206  -7.091 4.63e-12 ***\nlstat        -0.552019   0.050659 -10.897  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.798 on 493 degrees of freedom\nMultiple R-squared:  0.7343,    Adjusted R-squared:  0.7278 \nF-statistic: 113.5 on 12 and 493 DF,  p-value: < 2.2e-16\n\n\nWe can access the individual components of a summary object by name (type ?summary.lm to see what is available). Hence summary(lm.fit)$r.sq gives us the \\(R^2\\), and summary(lm.fit)$sigma gives us the RSE. The vif() function, part of the car package, can be used to compute variance inflation factors. Most VIF’s are low to moderate for this data. The car package is not part of the base R installation so it must be downloaded the first time you use it via the install.packages() function in R.\n\nlibrary(car)\n\nLoading required package: carData\n\nvif(lm.fit)\n\n    crim       zn    indus     chas      nox       rm      age      dis \n1.767486 2.298459 3.987181 1.071168 4.369093 1.912532 3.088232 3.954037 \n     rad      tax  ptratio    lstat \n7.445301 9.002158 1.797060 2.870777 \n\n\nWhat if we would like to perform a regression using all of the variables but one? For example, in the above regression output, age has a high \\(p\\)-value. So we may wish to run a regression excluding this predictor. The following syntax results in a regression using all predictors except age.\n\nlm.fit1 <- lm(medv ~ . - age, data = Boston)\nsummary(lm.fit1)\n\n\nCall:\nlm(formula = medv ~ . - age, data = Boston)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.1851  -2.7330  -0.6116   1.8555  26.3838 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  41.525128   4.919684   8.441 3.52e-16 ***\ncrim         -0.121426   0.032969  -3.683 0.000256 ***\nzn            0.046512   0.013766   3.379 0.000785 ***\nindus         0.013451   0.062086   0.217 0.828577    \nchas          2.852773   0.867912   3.287 0.001085 ** \nnox         -18.485070   3.713714  -4.978 8.91e-07 ***\nrm            3.681070   0.411230   8.951  < 2e-16 ***\ndis          -1.506777   0.192570  -7.825 3.12e-14 ***\nrad           0.287940   0.066627   4.322 1.87e-05 ***\ntax          -0.012653   0.003796  -3.333 0.000923 ***\nptratio      -0.934649   0.131653  -7.099 4.39e-12 ***\nlstat        -0.547409   0.047669 -11.483  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.794 on 494 degrees of freedom\nMultiple R-squared:  0.7343,    Adjusted R-squared:  0.7284 \nF-statistic: 124.1 on 11 and 494 DF,  p-value: < 2.2e-16\n\n\nAlternatively, the update() function can be used.\n\nlm.fit1 <- update(lm.fit, ~ . - age)"
  },
  {
    "objectID": "Ch3_RLab.html#interaction-terms",
    "href": "Ch3_RLab.html#interaction-terms",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "3.4 Interaction Terms",
    "text": "3.4 Interaction Terms\nIt is easy to include interaction terms in a linear model using the lm() function. The syntax lstat:black tells R to include an interaction term between lstat and black. The syntax lstat * age simultaneously includes lstat, age, and the interaction term lstat\\(\\times\\)age as predictors; it is a shorthand for lstat + age + lstat:age. %We can also pass in transformed versions of the predictors.\n\nsummary(lm(medv ~ lstat * age, data = Boston))\n\n\nCall:\nlm(formula = medv ~ lstat * age, data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.806  -4.045  -1.333   2.085  27.552 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 36.0885359  1.4698355  24.553  < 2e-16 ***\nlstat       -1.3921168  0.1674555  -8.313 8.78e-16 ***\nage         -0.0007209  0.0198792  -0.036   0.9711    \nlstat:age    0.0041560  0.0018518   2.244   0.0252 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.149 on 502 degrees of freedom\nMultiple R-squared:  0.5557,    Adjusted R-squared:  0.5531 \nF-statistic: 209.3 on 3 and 502 DF,  p-value: < 2.2e-16"
  },
  {
    "objectID": "Ch3_RLab.html#non-linear-transformations-of-the-predictors",
    "href": "Ch3_RLab.html#non-linear-transformations-of-the-predictors",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "3.5 Non-linear Transformations of the Predictors",
    "text": "3.5 Non-linear Transformations of the Predictors\nThe lm() function can also accommodate non-linear transformations of the predictors. For instance, given a predictor \\(X\\), we can create a predictor \\(X^2\\) using I(X^2). The function I() is needed since the ^ has a special meaning in a formula object; wrapping as we do allows the standard usage in R, which is to raise X to the power 2. We now perform a regression of medv onto lstat and lstat^2.\n\nlm.fit2 <- lm(medv ~ lstat + I(lstat^2))\nsummary(lm.fit2)\n\n\nCall:\nlm(formula = medv ~ lstat + I(lstat^2))\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.2834  -3.8313  -0.5295   2.3095  25.4148 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 42.862007   0.872084   49.15   <2e-16 ***\nlstat       -2.332821   0.123803  -18.84   <2e-16 ***\nI(lstat^2)   0.043547   0.003745   11.63   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.524 on 503 degrees of freedom\nMultiple R-squared:  0.6407,    Adjusted R-squared:  0.6393 \nF-statistic: 448.5 on 2 and 503 DF,  p-value: < 2.2e-16\n\n\nThe near-zero \\(p\\)-value associated with the quadratic term suggests that it leads to an improved model. We use the anova() function to further quantify the extent to which the quadratic fit is superior to the linear fit.\n\nlm.fit <- lm(medv ~ lstat)\nanova(lm.fit, lm.fit2)\n\nAnalysis of Variance Table\n\nModel 1: medv ~ lstat\nModel 2: medv ~ lstat + I(lstat^2)\n  Res.Df   RSS Df Sum of Sq     F    Pr(>F)    \n1    504 19472                                 \n2    503 15347  1    4125.1 135.2 < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nHere Model 1 represents the linear submodel containing only one predictor, lstat, while Model 2 corresponds to the larger quadratic model that has two predictors, lstat and lstat^2. The anova() function performs a hypothesis test comparing the two models. The null hypothesis is that the two models fit the data equally well, and the alternative hypothesis is that the full model is superior. Here the \\(F\\)-statistic is \\(135\\) and the associated \\(p\\)-value is virtually zero. This provides very clear evidence that the model containing the predictors lstat and lstat^2 is far superior to the model that only contains the predictor lstat. This is not surprising, since earlier we saw evidence for non-linearity in the relationship between medv and lstat. If we type\n\npar(mfrow = c(2, 2))\nplot(lm.fit2)\n\n\n\n\nthen we see that when the lstat^2 term is included in the model, there is little discernible pattern in the residuals.\nIn order to create a cubic fit, we can include a predictor of the form I(X^3). However, this approach can start to get cumbersome for higher-order polynomials. A better approach involves using the poly() function to create the polynomial within lm(). For example, the following command produces a fifth-order polynomial fit:\n\nlm.fit5 <- lm(medv ~ poly(lstat, 5))\nsummary(lm.fit5)\n\n\nCall:\nlm(formula = medv ~ poly(lstat, 5))\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-13.5433  -3.1039  -0.7052   2.0844  27.1153 \n\nCoefficients:\n                 Estimate Std. Error t value Pr(>|t|)    \n(Intercept)       22.5328     0.2318  97.197  < 2e-16 ***\npoly(lstat, 5)1 -152.4595     5.2148 -29.236  < 2e-16 ***\npoly(lstat, 5)2   64.2272     5.2148  12.316  < 2e-16 ***\npoly(lstat, 5)3  -27.0511     5.2148  -5.187 3.10e-07 ***\npoly(lstat, 5)4   25.4517     5.2148   4.881 1.42e-06 ***\npoly(lstat, 5)5  -19.2524     5.2148  -3.692 0.000247 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.215 on 500 degrees of freedom\nMultiple R-squared:  0.6817,    Adjusted R-squared:  0.6785 \nF-statistic: 214.2 on 5 and 500 DF,  p-value: < 2.2e-16\n\n\nThis suggests that including additional polynomial terms, up to fifth order, leads to an improvement in the model fit! However, further investigation of the data reveals that no polynomial terms beyond fifth order have significant \\(p\\)-values in a regression fit.\nBy default, the poly() function orthogonalizes the predictors: this means that the features output by this function are not simply a sequence of powers of the argument. However, a linear model applied to the output of the poly() function will have the same fitted values as a linear model applied to the raw polynomials (although the coefficient estimates, standard errors, and p-values will differ). In order to obtain the raw polynomials from the poly() function, the argument raw = TRUE must be used.\nOf course, we are in no way restricted to using polynomial transformations of the predictors. Here we try a log transformation.\n\nsummary(lm(medv ~ log(rm), data = Boston))\n\n\nCall:\nlm(formula = medv ~ log(rm), data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-19.487  -2.875  -0.104   2.837  39.816 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  -76.488      5.028  -15.21   <2e-16 ***\nlog(rm)       54.055      2.739   19.73   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.915 on 504 degrees of freedom\nMultiple R-squared:  0.4358,    Adjusted R-squared:  0.4347 \nF-statistic: 389.3 on 1 and 504 DF,  p-value: < 2.2e-16"
  },
  {
    "objectID": "Ch3_RLab.html#qualitative-predictors",
    "href": "Ch3_RLab.html#qualitative-predictors",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "3.6 Qualitative Predictors",
    "text": "3.6 Qualitative Predictors\nWe will now examine the Carseats data, which is part of the ISLR2 library. We will attempt to predict Sales (child car seat sales) in \\(400\\) locations based on a number of predictors.\n\nhead(Carseats)\n\n  Sales CompPrice Income Advertising Population Price ShelveLoc Age Education\n1  9.50       138     73          11        276   120       Bad  42        17\n2 11.22       111     48          16        260    83      Good  65        10\n3 10.06       113     35          10        269    80    Medium  59        12\n4  7.40       117    100           4        466    97    Medium  55        14\n5  4.15       141     64           3        340   128       Bad  38        13\n6 10.81       124    113          13        501    72       Bad  78        16\n  Urban  US\n1   Yes Yes\n2   Yes Yes\n3   Yes Yes\n4   Yes Yes\n5   Yes  No\n6    No Yes\n\n\nThe Carseats data includes qualitative predictors such as shelveloc, an indicator of the quality of the shelving location—that is, the space within a store in which the car seat is displayed—at each location. The predictor shelveloc takes on three possible values: Bad, Medium, and Good. Given a qualitative variable such as shelveloc, R generates dummy variables automatically. Below we fit a multiple regression model that includes some interaction terms.\n\nlm.fit <- lm(Sales ~ . + Income:Advertising + Price:Age, \n    data = Carseats)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = Sales ~ . + Income:Advertising + Price:Age, data = Carseats)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.9208 -0.7503  0.0177  0.6754  3.3413 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(>|t|)    \n(Intercept)         6.5755654  1.0087470   6.519 2.22e-10 ***\nCompPrice           0.0929371  0.0041183  22.567  < 2e-16 ***\nIncome              0.0108940  0.0026044   4.183 3.57e-05 ***\nAdvertising         0.0702462  0.0226091   3.107 0.002030 ** \nPopulation          0.0001592  0.0003679   0.433 0.665330    \nPrice              -0.1008064  0.0074399 -13.549  < 2e-16 ***\nShelveLocGood       4.8486762  0.1528378  31.724  < 2e-16 ***\nShelveLocMedium     1.9532620  0.1257682  15.531  < 2e-16 ***\nAge                -0.0579466  0.0159506  -3.633 0.000318 ***\nEducation          -0.0208525  0.0196131  -1.063 0.288361    \nUrbanYes            0.1401597  0.1124019   1.247 0.213171    \nUSYes              -0.1575571  0.1489234  -1.058 0.290729    \nIncome:Advertising  0.0007510  0.0002784   2.698 0.007290 ** \nPrice:Age           0.0001068  0.0001333   0.801 0.423812    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.011 on 386 degrees of freedom\nMultiple R-squared:  0.8761,    Adjusted R-squared:  0.8719 \nF-statistic:   210 on 13 and 386 DF,  p-value: < 2.2e-16\n\n\nThe contrasts() function returns the coding that R uses for the dummy variables.\n\nattach(Carseats)\ncontrasts(ShelveLoc)\n\n       Good Medium\nBad       0      0\nGood      1      0\nMedium    0      1\n\n\nUse ?contrasts to learn about other contrasts, and how to set them.\nR has created a ShelveLocGood dummy variable that takes on a value of 1 if the shelving location is good, and 0 otherwise. It has also created a ShelveLocMedium dummy variable that equals 1 if the shelving location is medium, and 0 otherwise. A bad shelving location corresponds to a zero for each of the two dummy variables. The fact that the coefficient for ShelveLocGood in the regression output is positive indicates that a good shelving location is associated with high sales (relative to a bad location). And ShelveLocMedium has a smaller positive coefficient, indicating that a medium shelving location is associated with higher sales than a bad shelving location but lower sales than a good shelving location."
  },
  {
    "objectID": "Ch3_RLab.html#writing-functions",
    "href": "Ch3_RLab.html#writing-functions",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "3.7 Writing Functions",
    "text": "3.7 Writing Functions\nAs we have seen, R comes with many useful functions, and still more functions are available by way of R libraries. However, we will often be interested in performing an operation for which no function is available. In this setting, we may want to write our own function. For instance, below we provide a simple function that reads in the ISLR2 and MASS libraries, called LoadLibraries(). Before we have created the function, R returns an error if we try to call it.\n\nLoadLibraries\n\nError in eval(expr, envir, enclos): object 'LoadLibraries' not found\n\nLoadLibraries()\n\nError in LoadLibraries(): could not find function \"LoadLibraries\"\n\n\nWe now create the function.\n\nLoadLibraries <- function() {\n library(ISLR2)\n library(MASS)\n print(\"The libraries have been loaded.\")\n}\n\nNow if we type in LoadLibraries, R will tell us what is in the function.\n\nLoadLibraries\n\nfunction() {\n library(ISLR2)\n library(MASS)\n print(\"The libraries have been loaded.\")\n}\n\n\nIf we call the function, the libraries are loaded in and the print statement is output.\n\nLoadLibraries()\n\n[1] \"The libraries have been loaded.\""
  },
  {
    "objectID": "Ch3_RLab.html#exercises",
    "href": "Ch3_RLab.html#exercises",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "3.8 Exercises",
    "text": "3.8 Exercises\nPrepare the following exercises of Chapter 3 in our course textbook ISLR:\n\nExercise 1\nExercise 2\nExercise 3\nExercise 8\nExercise 9"
  },
  {
    "objectID": "Ch3_RLab.html#solutions",
    "href": "Ch3_RLab.html#solutions",
    "title": "3  R-Lab Ch 3: Linear Regression”",
    "section": "3.9 Solutions",
    "text": "3.9 Solutions\n\n3.9.1 Exercise 1\n1 a) Describe the null hypotheses to which the \\(p\\)-values given in Table 3.4 correspond.\n\n1 b) Explain what conclusions you can draw based on these \\(p\\)-values. Your explanation should be phrased in terms of sales, TV, radio, and newspaper, rather than in terms of the coefficients of the linear model.\nAnswers:\n1 a) In Table 3.4, the null hypothesis for TV is that in the presence of radio ads and newspaper ads, TV ads have no effect on sales. Similarly, the null hypothesis for radio is that in the presence of TV ads and newspaper ads, radio ads have no effect on sales.\n1 b) On the one hand, the low p-values of TV and radio allow us to reject the null hypothesis for TV and radio. Hence, we believe that TV (radio) ads have an effect on sales in the presence of radio (TV) and newspaper ads. On the other hand, the high p-value of newspaper does not allow us to reject the null-hypothesis (of no effect, i.e. a coefficient zero). This is an inconclusive result and only says that possible effects of newspaper ads are not large enough to stand out from the estimation errors (quantified by the standard error).\nRemember: An insignificant hypothesis test-result is never informative about whether the null is true. We do not have an error-control for falsely accepting the null-hypothesis. We only have an error-control (by the significance level) for falsely rejecting the null-hypothesis.\n\n\n3.9.2 Exercise 2\nCarefully explain the main difference between the KNN classifier and KNN regression methods.\nAnswer:\nKNN classifier and KNN regression methods are closely related in formula. However, the final result of KNN classifier is the classification output for \\(Y\\) (qualitative), where as the output for a KNN regression predicts the quantitative value for \\(f(X)\\).\n\n\n3.9.3 Exercise 3\nSuppose we have a data set with five predictors:\n\\(X_1 =GPA\\)\n\\(X_2 = IQ\\)\n\\(X_3 = Gender\\) (\\(1\\) for Female and \\(0\\) for Male)\n\\(X_4 =\\) Interaction between \\(GPA\\) and \\(IQ\\)\n\\(X_5 =\\) Interaction between \\(GPA\\) and \\(Gender\\)\nThe response variable (in thousands of dollars) is defined as:\n\\(Y =\\) starting salary after graduation\nSuppose we use least squares to fit the model, and get:\n\\(\\hat{\\beta}_0 = 50\\), \\(\\hat{\\beta}_1 = 20\\), \\(\\hat{\\beta}_2 = 0.07\\), \\(\\hat{\\beta}_3 = 35\\), \\(\\hat{\\beta}_4 = 0.01\\), and \\(\\hat{\\beta}_5 = −10\\).\nThus we have:\n\\[\n\\begin{align*}\n&E[Y|X] = \\\\\n& 50 + 20\\,\\overbrace{GPA}^{X_1} + 0.07\\,\\overbrace{IQ}^{X_2} + 35\\,\\overbrace{Gender}^{X_3} +\n0.01\\,\\underbrace{GPA\\cdot IQ}_{X_4=X_1\\cdot X_2} - 10\\,\\underbrace{GPA\\cdot Gender}_{X_5=X_1\\cdot X_3}\n\\end{align*}\n\\]\n3 a) Which answer is correct, and why?\n\nFor a fixed value of \\(IQ\\) and \\(GPA\\), males earn more on average than females.\nFor a fixed value of \\(IQ\\) and \\(GPA\\), females earn more on average than males.\nFor a fixed value of \\(IQ\\) and \\(GPA\\), males earn more on average than females provided that the \\(GPA\\) is high enough.\nFor a fixed value of \\(IQ\\) and \\(GPA\\), females earn more on average than males provided that the \\(GPA\\) is high enough.\n\nAnswer: \\[\n\\begin{align*}\n\\text{Male\\; $(X_3 = 0)$:}\\quad   & 50 + 20 X_1 + 0.07 X_2 + \\phantom{3}0 + 0.01\\,(X_1 \\cdot X_2) -0     \\\\[1.5ex]\n\\text{Female\\; $(X_3 = 1)$:}\\quad & 50 + 20 X_1 + 0.07 X_2 + 35 + 0.01(X_1 \\cdot X_2) - 10\\,X_1\n\\end{align*}\n\\] Thus, once the \\(X_1=\\)GPA is high enough (\\(35-10\\,X_1<0 \\Leftrightarrow X_1>3.5\\)), males earn more on average.\n3 b) Predict the salary of a female with IQ of 110 and a GPA of 4.0.\nAnswer:\n\nY_hat <- 50 + 20*4 + 0.07*110 + 35*1 + 0.01*4*110 - 10*4\nY_hat\n\n[1] 137.1\n\n\n3 c) True or false: Since the coefficient for the \\(GPA\\cdot IQ\\) interaction term is very small, there is very little evidence of an interaction effect. Justify your answer.\nAnswer:\nFalse. We must examine the \\(p\\)-value of the regression coefficient to determine if the interaction term is statistically significant or not.\n\n\n3.9.4 Exercise 8\nThis question involves the use of simple linear regression on the Auto data set.\n8 a) Use the lm() function to perform a simple linear regression with mpg as the response and horsepower as the predictor. Use the summary() function to print the results. Comment on the output (see questions i) to iv) below).\n\n# Store data into dataframe Auto\nAuto <- read.csv(\"DATA/Auto.csv\", header=TRUE, na.strings=\"?\")\n\n# Remove missing values from the data\nAuto <- na.omit(Auto)\n\n# Perform linear regression\nfit.lm <- lm(mpg ~ horsepower, data=Auto)\n\n# Use summary function to print the results\nsummary(fit.lm)\n\n\nCall:\nlm(formula = mpg ~ horsepower, data = Auto)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-13.5710  -3.2592  -0.3435   2.7630  16.9240 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 39.935861   0.717499   55.66   <2e-16 ***\nhorsepower  -0.157845   0.006446  -24.49   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.906 on 390 degrees of freedom\nMultiple R-squared:  0.6059,    Adjusted R-squared:  0.6049 \nF-statistic: 599.7 on 1 and 390 DF,  p-value: < 2.2e-16\n\n\ni) Is there a relationship between the predictor and the response?\nAnswer:\nYes, there is. The predictor horsepower has a statistically significant (\\(p<0.001\\)) linear relationship with the response.\nii) How strong is the relationship between the predictor and the response?\nAnswer:\nStatistical significance does not necessarily mean a practically strong or important relationship.\nTo quantify the strength of the relationship between the predictor and the response, we can look at the following quantities:\n\nResidual Standard Error RSE (estimate of the standard deviation of \\(\\epsilon\\))\nThe \\(R^2\\) Statistic (the proportion of variance explained by the model)\nThe \\(F\\)-Statistic.\n\nThe Residual Standard Error RSE of the regression model with intercept and horsepower as predictors is given by:\n\n## RSE of lm(mpg ~ horsepower)\nRSS <- sum(resid(fit.lm)^2)\nn   <- length(resid(fit.lm))\nRSE <- sqrt(RSS/(n-2))\nround(RSE, 3)\n\n[1] 4.906\n\n\nThis is considerable smaller than the RSE of a model with only an intercept:\n\nRSS_onlyIntercept <- sum(c(Auto$mpg - mean(Auto$mpg))^2)\nRSE_onlyIntercept <- sqrt(RSS_onlyIntercept/(n-1))\nround(RSE_onlyIntercept, 3)\n\n[1] 7.805\n\n\nThus, the larger model with horsepower included explains more of the varinces in the response variable mpg.\nThe \\(R^2\\) value\n\nround(summary(fit.lm)$r.squared, 2)\n\n[1] 0.61\n\n\nshows that \\(60\\%\\) of variability in \\(Y\\) can be explained using \\(X\\).\nThe value of the \\(F\\) statistic ::: {.cell}\nround(summary(fit.lm)$fstatistic, 2)\n\n value  numdf  dendf \n599.72   1.00 390.00 \n\n::: is much larger than \\(1\\) which means that we probably can reject the null hypothesis that \\(\\beta_{horsepower}=0\\).\niii) Is the relationship between the predictor and the response positive or negative?\nAnswer:\nThe relationship is negative, as we can see from the parameter estimate for horsepower\n\ncoef(fit.lm)\n\n(Intercept)  horsepower \n 39.9358610  -0.1578447 \n\n\niv) What is the predicted mpg associated with a horsepower of \\(98\\)? What are the associated \\(95\\%\\) confidence and prediction intervals?\nAnswer:\n\n# Horsepower of 98\nnew_df <- data.frame(horsepower = 98)\n\n# confidence interval \nprint(predict(object = fit.lm, newdata = new_df, interval = \"confidence\"))\n\n       fit      lwr      upr\n1 24.46708 23.97308 24.96108\n\n# prediction interval\nprint(predict(object = fit.lm, newdata = new_df, interval = \"prediction\"))\n\n       fit     lwr      upr\n1 24.46708 14.8094 34.12476\n\n\n8 b) Plot the response and the predictor. Use the abline() function to display the least squares regression line.\nAnswer:\n\nplot(x = Auto$horsepower, y = Auto$mpg, ylab = \"MPG\", xlab = \"Horsepower\")\nabline(fit.lm, col=\"blue\")\nlegend(\"topright\", legend = c(\"(y,x)\", expression(paste(\"(\",hat(y),\"x)\"))), \n       pch=c(1,NA), lty=c(NA,1), col=c(\"black\", \"blue\"))\n\n\n\n\n8 c) Use the plot() function to produce diagnostic plots of the least squares regression fit. Comment on any problems you see with the fit.\nAnswer:\n\npar(mfrow=c(2,2))\nplot(fit.lm, col='blue')\n\n\n\n\nLooking at the smoothing line of the residuals (\\(e_i=y_i−\\hat{y}_i\\)) vs the fitted values (\\(\\hat{y}_i\\)), there is a strong pattern in the residuals, indicating non-linearity. You can see evidence of this in the scatter plot in part 8 b) too.\nThere also appears to be non-constant variance in the error terms (heteroscedasticity), but this could be corrected to an extent when trying a quadratic fit. If not, transformations such as \\(log(y)\\) or \\(\\sqrt{y}\\) can shrink larger responses by a greater amount and reduce this issue.\nThere are some observations with large standardized residuals & high leverage (hence, high Cook’s Distance) that may want to be reviewed.\n\n\n3.9.5 Exercise 9\nThis question involves the use of multiple linear regression on the Auto data set.\n9 a) Produce a scatterplot matrix which includes all of the variables in the data set.\nAnswer:\n\n# Store data into dataframe Auto\nAuto <- read.csv(\"DATA/Auto.csv\", header=T, na.strings=\"?\")\n\n# Remove missing values from the data\nAuto <- na.omit(Auto)\n\n# Produce scatterplot matrix\npairs(Auto[,-9])\n\n\n\n\n9 b) Compute the matrix of correlations between the variables using the function cor(). You will need to exclude the name variable, which is qualitative.\nAnswer:\n\nround(cor(subset(Auto, select = -name)), 2)\n\n               mpg cylinders displacement horsepower weight acceleration  year\nmpg           1.00     -0.78        -0.81      -0.78  -0.83         0.42  0.58\ncylinders    -0.78      1.00         0.95       0.84   0.90        -0.50 -0.35\ndisplacement -0.81      0.95         1.00       0.90   0.93        -0.54 -0.37\nhorsepower   -0.78      0.84         0.90       1.00   0.86        -0.69 -0.42\nweight       -0.83      0.90         0.93       0.86   1.00        -0.42 -0.31\nacceleration  0.42     -0.50        -0.54      -0.69  -0.42         1.00  0.29\nyear          0.58     -0.35        -0.37      -0.42  -0.31         0.29  1.00\norigin        0.57     -0.57        -0.61      -0.46  -0.59         0.21  0.18\n             origin\nmpg            0.57\ncylinders     -0.57\ndisplacement  -0.61\nhorsepower    -0.46\nweight        -0.59\nacceleration   0.21\nyear           0.18\norigin         1.00\n\n\n9 c) Use the lm() function to perform a multiple linear regression with mpg as the response and all other variables except name as the predictors. Use the summary() function to print the results. Comment on the output by answering the below questions 9 c i) to 9 c iii).\nAnswer:\n\n# Perform multiplie linear regression\nfit.lm <- lm(mpg ~ .-name, data=Auto)\n\n# Print results\nsummary(fit.lm)\n\n\nCall:\nlm(formula = mpg ~ . - name, data = Auto)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-9.5903 -2.1565 -0.1169  1.8690 13.0604 \n\nCoefficients:\n               Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  -17.218435   4.644294  -3.707  0.00024 ***\ncylinders     -0.493376   0.323282  -1.526  0.12780    \ndisplacement   0.019896   0.007515   2.647  0.00844 ** \nhorsepower    -0.016951   0.013787  -1.230  0.21963    \nweight        -0.006474   0.000652  -9.929  < 2e-16 ***\nacceleration   0.080576   0.098845   0.815  0.41548    \nyear           0.750773   0.050973  14.729  < 2e-16 ***\norigin         1.426141   0.278136   5.127 4.67e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.328 on 384 degrees of freedom\nMultiple R-squared:  0.8215,    Adjusted R-squared:  0.8182 \nF-statistic: 252.4 on 7 and 384 DF,  p-value: < 2.2e-16\n\n\n9 c i) Is there a relationship between the predictors and the response?\nAnswer:\nYes, there is a relationship between the predictors and the response. By testing the null hypothesis of whether all the regression coefficients are zero (i.e. H\\(_0\\): \\(\\beta_1=\\dots=\\beta_7=0\\)), we can see that the \\(F\\)-statistic is big and its \\(p\\)-value is close to zero, indicating evidence against the null hypothesis.\n9 c ii) Which predictors appear to have a statistically significant relationship to the response?\nAnswer:\nLooking at the \\(p\\)-values associated with each predictor’s \\(t\\)-statistic, we see that displacement, weight, year, and origin have a statistically significant relationship, while cylinders, horsepower, and acceleration do not.\n(Caution: This consideration neglects issues due to multiple testing. Bonferroni correction for multiple testing: To determine if any of the \\(7\\) predictors is statistically significant, the corresponding \\(p\\)-value must be smaller than \\(\\alpha/7\\). For instance, with \\(\\alpha/7=0.05/7\\approx 0.007\\), only weight, year, and origin have a statistically significant relationships to the response.)\n9 c iii) What does the coefficient for the year variable suggest?\nAnswer:\nThe regression coefficient for year suggests that, on average, one year later year-of-construction is associated with an increased mpg by \\(0.75\\), when holding every other predictor value constant.\n9 d) Use the plot() function to produce diagnostic plots of the linear regression fit. Comment on any problems you see with the fit. Do the residual plots suggest any unusually large outliers? Does the leverage plot identify any observations with unusually high leverage?\nAnswer:\n\npar(mfrow=c(2,2))\nplot(fit.lm, col='blue')\n\n\n\n\n\nThe “Residuals vs Fitted” plot (top left) shows some systematic deviations of the residuals from \\(0\\). The reason is that we are imposing a straight line fit for the conditional mean function \\(E[Y|X]=f(X)\\) which appears non-linear here. This results in a systematic underestimation of the true conditional mean function for large and small fitted values \\(\\hat{y}=\\hat\\beta_0+\\hat\\beta_1x_1+\\dots+\\hat\\beta_px_p\\).\nThe “Residuals vs Leverage” plot (bottom right) shows that there are some potential outliers that we can see when: standardized residuals are below \\(-2\\) or above \\(+2\\). Moreover, the plot shows also potentially problematic “high-leverage” points with leverage values heavily exceeding the rule-of-thumb threshold \\((p+ 1)/n=8/392=0.02\\). All points with simultaneously high-leverages and large absolute standardized residuals should be handled with care since these may distort the estimation.\nThe “Normal Q-Q” plot (top right) suggests non-normally distributed residuals–particularly the upper tail deviates from that of a normal distribution.\nThe “Scale-Location” plot (bottom left) shows heteroscedastic residuals with larger variances for larger fitted values \\(\\hat{y}=\\hat\\beta_0+\\hat\\beta_1x_1+\\dots+\\hat\\beta_px_p\\).\n\n9 e) Use the * and : symbols to fit linear regression models with interaction effects. Do any interactions appear to be statistically significant?\nAnswer:\n\nfit.lm0 <- lm(mpg ~ horsepower+cylinders+year+weight:displacement, \n              data=Auto)\nsummary(fit.lm0)\n\n\nCall:\nlm(formula = mpg ~ horsepower + cylinders + year + weight:displacement, \n    data = Auto)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-9.1046 -2.8861 -0.2415  2.3967 15.3221 \n\nCoefficients:\n                      Estimate Std. Error t value Pr(>|t|)    \n(Intercept)         -1.343e+01  5.043e+00  -2.663  0.00807 ** \nhorsepower          -3.914e-02  1.278e-02  -3.063  0.00234 ** \ncylinders           -1.358e+00  3.233e-01  -4.201 3.31e-05 ***\nyear                 6.661e-01  6.019e-02  11.067  < 2e-16 ***\nweight:displacement -3.354e-06  1.352e-06  -2.480  0.01355 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.985 on 387 degrees of freedom\nMultiple R-squared:  0.7419,    Adjusted R-squared:  0.7393 \nF-statistic: 278.2 on 4 and 387 DF,  p-value: < 2.2e-16\n\n\n\nfit.lm1 <- lm(mpg~horsepower+cylinders+year+weight*displacement, \n              data=Auto)\nsummary(fit.lm1)\n\n\nCall:\nlm(formula = mpg ~ horsepower + cylinders + year + weight * displacement, \n    data = Auto)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-9.7530 -1.8228 -0.0602  1.5780 12.6133 \n\nCoefficients:\n                      Estimate Std. Error t value Pr(>|t|)    \n(Intercept)         -2.210e+00  3.819e+00  -0.579  0.56316    \nhorsepower          -3.396e-02  9.560e-03  -3.552  0.00043 ***\ncylinders            2.072e-01  2.914e-01   0.711  0.47756    \nyear                 7.858e-01  4.555e-02  17.250  < 2e-16 ***\nweight              -1.084e-02  6.346e-04 -17.076  < 2e-16 ***\ndisplacement        -7.947e-02  9.905e-03  -8.023 1.26e-14 ***\nweight:displacement  2.431e-05  2.141e-06  11.355  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.976 on 385 degrees of freedom\nMultiple R-squared:  0.8568,    Adjusted R-squared:  0.8546 \nF-statistic: 384.1 on 6 and 385 DF,  p-value: < 2.2e-16\n\n\n\nNote that there is a difference between using A:B and A*B when running a regression. While the first includes only the interaction term between the variable A and B, the second one also includes the stand-alone variables A and B.\nFollow the hierarchical principle for interaction effects: If we include an interaction in a model, we should also include the main effects, even if the \\(p\\)-values associated with their coeffcients are not significant.\n\n9 f)\nTry a few different transformations of the variables, such as \\(\\log(X)\\), \\(\\sqrt{X}\\), \\(X^2\\). Comment on your findings.\nAnswer:\n\nfit.lm2 <- lm(mpg~log(weight)+sqrt(horsepower)+\n                acceleration+I(acceleration^2),\n              data=Auto)\nsummary(fit.lm2)\n\n\nCall:\nlm(formula = mpg ~ log(weight) + sqrt(horsepower) + acceleration + \n    I(acceleration^2), data = Auto)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-11.2932  -2.5082  -0.2237   2.0237  15.7650 \n\nCoefficients:\n                   Estimate Std. Error t value Pr(>|t|)    \n(Intercept)       178.30303   10.80451  16.503  < 2e-16 ***\nlog(weight)       -14.74259    1.73994  -8.473 5.06e-16 ***\nsqrt(horsepower)   -1.85192    0.36005  -5.144 4.29e-07 ***\nacceleration       -2.19890    0.63903  -3.441 0.000643 ***\nI(acceleration^2)   0.06139    0.01857   3.305 0.001037 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.99 on 387 degrees of freedom\nMultiple R-squared:  0.7414,    Adjusted R-squared:  0.7387 \nF-statistic: 277.3 on 4 and 387 DF,  p-value: < 2.2e-16\n\npar(mfrow=c(2,2))\nplot(fit.lm2)\n\n\n\n\nThis try suffers basically from the same issues as the model considered in 9 d)\nLet’s consider again the model with all predictors (except name), but with transforming the outcome variable mpg by a \\(\\log\\)-transformation.\n\nfit.lm3 <-lm(log(mpg)~ . -name, data=Auto)\nsummary(fit.lm3)\n\n\nCall:\nlm(formula = log(mpg) ~ . - name, data = Auto)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.40955 -0.06533  0.00079  0.06785  0.33925 \n\nCoefficients:\n               Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   1.751e+00  1.662e-01  10.533  < 2e-16 ***\ncylinders    -2.795e-02  1.157e-02  -2.415  0.01619 *  \ndisplacement  6.362e-04  2.690e-04   2.365  0.01852 *  \nhorsepower   -1.475e-03  4.935e-04  -2.989  0.00298 ** \nweight       -2.551e-04  2.334e-05 -10.931  < 2e-16 ***\nacceleration -1.348e-03  3.538e-03  -0.381  0.70339    \nyear          2.958e-02  1.824e-03  16.211  < 2e-16 ***\norigin        4.071e-02  9.955e-03   4.089 5.28e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.1191 on 384 degrees of freedom\nMultiple R-squared:  0.8795,    Adjusted R-squared:  0.8773 \nF-statistic: 400.4 on 7 and 384 DF,  p-value: < 2.2e-16\n\npar(mfrow=c(2,2))\nplot(fit.lm3)\n\n\n\n\nThis model specification is much better!\n\nNo clear issues of systematic under/over estimations for given fitted values.\nNo clear issues of heteroscedastic residuals."
  },
  {
    "objectID": "Ch2_RLab.html#solutions",
    "href": "Ch2_RLab.html#solutions",
    "title": "2  R-Lab Ch 2: Introduction to R",
    "section": "2.10 Solutions",
    "text": "2.10 Solutions\n\nExercise 7\nThe table below provides a training data set containing six observations, three predictors, and one qualitative response variable. Suppose we wish to use this data set to make a prediction for \\(Y\\) when \\(X_1 = X_2 = X_3 = 0\\) using K-nearest neighbors.\n\n\n\nObs.\n\\(X_1\\)\n\\(X_2\\)\n\\(X_3\\)\n\\(Y\\)\n\n\n\n\n1\n0\n3\n0\nRed\n\n\n2\n2\n0\n0\nRed\n\n\n3\n0\n1\n3\nRed\n\n\n4\n0\n1\n2\nGreen\n\n\n5\n−1\n0\n1\nGreen\n\n\n6\n1\n1\n1\nRed\n\n\n\n7. a) Compute the Euclidean distance between each observation and the test point, \\(X_1 = X_2 = X_3 = 0\\).\nAnswer:\n\n# Observations\nobs1 <- c( 0, 3, 0)\nobs2 <- c( 2, 0, 0)\nobs3 <- c( 0, 1, 3)\nobs4 <- c( 0, 1, 2)\nobs5 <- c(-1, 0, 1)\nobs6 <- c( 1, 1, 1)\n\n# Test Point\nobs0 <- c(0, 0, 0)\n\n# Create a Vector Dist_vec to store the results\nDist <- numeric(length = 6)\n\n# Compute and store the Euclidean distances\nDist[1] <- (dist1 <- sqrt(sum((obs1-obs0)^2)) )\nDist[2] <- (dist2 <- sqrt(sum((obs2-obs0)^2)) )\nDist[3] <- (dist3 <- sqrt(sum((obs3-obs0)^2)) )\nDist[4] <- (dist4 <- sqrt(sum((obs4-obs0)^2)) )\nDist[5] <- (dist5 <- sqrt(sum((obs5-obs0)^2)) )\nDist[6] <- (dist6 <- sqrt(sum((obs6-obs0)^2)) )\n\n# Print the results\nDist\n\n[1] 3.000000 2.000000 3.162278 2.236068 1.414214 1.732051\n\n\n7. b) What is your prediction with \\(K = 1\\)? Why?\nAnswer: ::: {.cell}\nwhich.min(Dist)\n\n[1] 5\n\n:::\nClosest 1 neighbor is obs5 and thus, our prediction is Green because Green is the \\(Y\\) value associated to obs5.\n7. c) What is your prediction with \\(K = 3\\)? Why?\nAnswer: ::: {.cell}\norder(Dist)[1:3]\n\n[1] 5 6 2\n\n:::\nClosest 3 neighbors are obs5, obs6, obs2 and thus, our prediction is Red because it is the \\(Y\\) value associated to obs2 and obs6 (majority rule).\n7. d) If the Bayes decision boundary in this problem is highly nonlinear, then would we expect the best value for \\(K\\) to be large or small? Why?\nAnswer:\nA large value of K means that the \\(Y\\)-values from a large neighborhood are contributing to the prediction at one chosen \\(X\\)-point. This requires that the neighborhood consists of relatively similar \\(Y\\)-values. However, in the case of a highly nonlinear decision boundary, the neighborhoods of similar \\(Y\\)-values become generally small. Therefore, also \\(K\\) must be chosen relatively small so that we can capture more of the non-linear decision boundary. \n\n\nExercise 8:\nThis exercise relates to the College data set, which can be found in the file College.csv. It contains a number of variables for \\(777\\) different universities and colleges in the US. The variables are:\n\nPrivate : Public/private indicator\nApps : Number of applications received\nAccept : Number of applicants accepted\nEnroll : Number of new students enrolled\nTop10perc : New students from top 10% of high school class\nTop25perc : New students from top 25% of high school class\nF.Undergrad : Number of full-time undergraduates\nP.Undergrad : Number of part-time undergraduates\nOutstate : Out-of-state tuition\nRoom.Board : Room and board costs\nBooks : Estimated book costs\nPersonal : Estimated personal spending\nPhD : Percent of faculty with Ph.D.’s\nTerminal : Percent of faculty with terminal degree\nS.F.Ratio : Student/faculty ratio\nperc.alumni : Percent of alumni who donate\nExpend : Instructional expenditure per student\nGrad.Rate : Graduation rate\n\n8. a) Use the read.csv() function to read the data into R. Call the loaded data college. Make sure that you have the directory set to the correct location for the data.\nAnswer:\n\n# Store data into dataframe college\ncollege <- read.csv(\"DATA/College.csv\")\n\n# Print first 10 rows and 5 collumns of the data\nprint(college[c(1:10),c(1:5)])\n\n                              X Private Apps Accept Enroll\n1  Abilene Christian University     Yes 1660   1232    721\n2            Adelphi University     Yes 2186   1924    512\n3                Adrian College     Yes 1428   1097    336\n4           Agnes Scott College     Yes  417    349    137\n5     Alaska Pacific University     Yes  193    146     55\n6             Albertson College     Yes  587    479    158\n7       Albertus Magnus College     Yes  353    340    103\n8                Albion College     Yes 1899   1720    489\n9              Albright College     Yes 1038    839    227\n10    Alderson-Broaddus College     Yes  582    498    172\n\n\n8. b) Look at the data using the fix() function.\nAnswer:\nYou should notice that the first column is just the name of each university. We don’t really want R to treat this as data. However, it may be handy to have these names for later. Try the following commands:\n\n# Store row names\nrownames(college) <- college[,1]\n\n# pops up a window for data visualization\n# fix(college)\n\nYou should see that there is now a row.names column with the name of each university recorded. This means that R has given each row a name corresponding to the appropriate university. R will not try to perform calculations on the row names. However, we still need to eliminate the first column in the data where the names are stored. Try:\n\n# Eliminates first column (containing the row names)\ncollege <- college[,-1]\n# fix(college)\n\nNow you should see that the first data column is Private. Note that another column labeled row.names now appears before the Private column. However, this is not a data column but rather the name that R is giving to each row.\n8. c. i) Use the summary() function to produce a numerical summary of the variables in the data set.\nAnswer:\n\nsummary(college[, 1:5])\n\n   Private               Apps           Accept          Enroll    \n Length:777         Min.   :   81   Min.   :   72   Min.   :  35  \n Class :character   1st Qu.:  776   1st Qu.:  604   1st Qu.: 242  \n Mode  :character   Median : 1558   Median : 1110   Median : 434  \n                    Mean   : 3002   Mean   : 2019   Mean   : 780  \n                    3rd Qu.: 3624   3rd Qu.: 2424   3rd Qu.: 902  \n                    Max.   :48094   Max.   :26330   Max.   :6392  \n   Top10perc    \n Min.   : 1.00  \n 1st Qu.:15.00  \n Median :23.00  \n Mean   :27.56  \n 3rd Qu.:35.00  \n Max.   :96.00  \n\n\n8. c. ii) Use the pairs() function to produce a scatterplot matrix of the 2nd to 10th column or variables of the data. Recall that you can reference the 2nd to 10th column of a matrix A using A[,2:10].\nAnswer:\n\npairs(x = college[,2:10])\n\n\n\n\n8. c. iii) Use the boxplot() function to produce side-by-side boxplots of Outstate versus Private.\nAnswer:\n\nboxplot(Outstate~Private, \n        data = college, \n        xlab = \"Private\", \n        ylab = \"Outstate\")\n\n\n\n\n8. c. iv) Create a new qualitative variable, called Elite, by binning the Top10perc variable. We are going to divide universities into two groups based on whether or not the proportion of students coming from the top 10% of their high school classes exceeds 50%.\n\n# Creating a vector called ELite with only \"No\" entrances amounting the number of college rows\nElite <- rep(\"No\",nrow(college))\n\n# Replacing \"No\" with \"Yes\" if the proportion of students coming from the top 10% of their HS classes exceeds 50%.\nElite[college$Top10perc > 50] <- \"Yes\"\n\n# Encode a vector as a factor\nElite <- as.factor(Elite)\n\n# Add Elite variable to our current dataset \"college\"\ncollege <- data.frame(college, Elite)\n\nUse the summary() function to see how many elite universities there are. Now use the boxplot() function to produce side-by-side boxplots of Outstate versus Elite.\nAnswer:\n\nsummary(college$Elite)\n\n No Yes \n699  78 \n\n\nThere are \\(78\\) elite Universities. The boxplots of Outstate versus Elite-Status are generated as following:\n\nboxplot(Outstate ~ Elite, \n        data = college, xlab=\"Elite\", ylab=\"Outstate\")\n\n\n\n\n8. c. v) Use the hist() function to produce some histograms with differing numbers of bins for a few of the quantitative variables. You may find the command par(mfrow=c(2,2)) useful: it will divide the print window into four regions so that four plots can be made simultaneously. Modifying the arguments to this function will divide the screen in other ways.\nAnswer:\n\npar(mfrow=c(2,2))\nhist(college$Apps,     breaks=50, xlim=c(0,25000), \n     main=\"Apps\")\nhist(college$Enroll,   breaks=25, main=\"Enroll\")\nhist(college$Expend,   breaks=25, main=\"Expend\")\nhist(college$Outstate, main=\"Outstate\")\n\n\n\npar(mfrow=c(1,1))\n\n\n\nExercise 9:\nThis exercise involves the Auto data set. Make sure that the missing values have been removed from the data.\n\n# Store data into dataframe college\nAuto <- read.csv(\"DATA/Auto.csv\", header=T, na.strings=\"?\")\n\n# Remove missing values from the data\nAuto <- na.omit(Auto)\n\n# Print first 10 rows of the data\nprint(Auto[c(1:10),])\n\n   mpg cylinders displacement horsepower weight acceleration year origin\n1   18         8          307        130   3504         12.0   70      1\n2   15         8          350        165   3693         11.5   70      1\n3   18         8          318        150   3436         11.0   70      1\n4   16         8          304        150   3433         12.0   70      1\n5   17         8          302        140   3449         10.5   70      1\n6   15         8          429        198   4341         10.0   70      1\n7   14         8          454        220   4354          9.0   70      1\n8   14         8          440        215   4312          8.5   70      1\n9   14         8          455        225   4425         10.0   70      1\n10  15         8          390        190   3850          8.5   70      1\n                        name\n1  chevrolet chevelle malibu\n2          buick skylark 320\n3         plymouth satellite\n4              amc rebel sst\n5                ford torino\n6           ford galaxie 500\n7           chevrolet impala\n8          plymouth fury iii\n9           pontiac catalina\n10        amc ambassador dpl\n\n# Find more info on the variables here: https://rstudio-pubs-static.s3.amazonaws.com/61800_faea93548c6b49cc91cd0c5ef5059894.html\n\n9. a) Which of the predictors are quantitative, and which are qualitative?\nAnswer:\n\n# Summarize dataset\nsummary(Auto)\n\n      mpg          cylinders      displacement     horsepower        weight    \n Min.   : 9.00   Min.   :3.000   Min.   : 68.0   Min.   : 46.0   Min.   :1613  \n 1st Qu.:17.00   1st Qu.:4.000   1st Qu.:105.0   1st Qu.: 75.0   1st Qu.:2225  \n Median :22.75   Median :4.000   Median :151.0   Median : 93.5   Median :2804  \n Mean   :23.45   Mean   :5.472   Mean   :194.4   Mean   :104.5   Mean   :2978  \n 3rd Qu.:29.00   3rd Qu.:8.000   3rd Qu.:275.8   3rd Qu.:126.0   3rd Qu.:3615  \n Max.   :46.60   Max.   :8.000   Max.   :455.0   Max.   :230.0   Max.   :5140  \n  acceleration        year           origin          name          \n Min.   : 8.00   Min.   :70.00   Min.   :1.000   Length:392        \n 1st Qu.:13.78   1st Qu.:73.00   1st Qu.:1.000   Class :character  \n Median :15.50   Median :76.00   Median :1.000   Mode  :character  \n Mean   :15.54   Mean   :75.98   Mean   :1.577                     \n 3rd Qu.:17.02   3rd Qu.:79.00   3rd Qu.:2.000                     \n Max.   :24.80   Max.   :82.00   Max.   :3.000                     \n\n\n\nQuantitative predictors: mpg, cylinders, displacement, horsepower, weight, acceleration, year\nQualitative predictors: name, origin\n\n9. b) What is the range of each quantitative predictor? You can answer this using the range() function.\nAnswer:\n\n# apply the range function to the first seven columns of Auto\nc <- sapply(Auto[, 1:7], range)\n# print to console\nc\n\n      mpg cylinders displacement horsepower weight acceleration year\n[1,]  9.0         3           68         46   1613          8.0   70\n[2,] 46.6         8          455        230   5140         24.8   82\n\n\n9. c) What is the mean and standard deviation of each quantitative predictor?\nAnswer:\n\n# compute mean for the first seven variables and store it in a vector\nmean <- sapply(Auto[,1:7], mean)\n\n# round the values inside the vectors to 2 decimal cases\nmean <- sapply(mean,round,2)\n\n# compute the standard deviation and round it up \nsd <- sapply(Auto[, 1:7], sd)\nsd <- sapply(sd,round,2)\n\n# print both vectors\nmean\n\n         mpg    cylinders displacement   horsepower       weight acceleration \n       23.45         5.47       194.41       104.47      2977.58        15.54 \n        year \n       75.98 \n\nsd\n\n         mpg    cylinders displacement   horsepower       weight acceleration \n        7.81         1.71       104.64        38.49       849.40         2.76 \n        year \n        3.68 \n\n\n9.d) Now remove the 10th through 85th observations. What is the range, mean, and standard deviation of each predictor in the subset of the data that remains?\nAnswer:\n\n# remove observations and store them \nnewAuto = Auto[-(10:85),]\n\n# Re-do exercises 9. b) and 9.c)\n# This time, create an empty Matrix \"Results\" to store the results\nResults <- matrix(NA, nrow = 4, ncol = 7, \n                  dimnames = list(c(\"Mean\", \"SD\", \"Minimum\", \"Maximum\"), \n                                  c(colnames(newAuto[,1:7]))))\n\n# Store the results\nResults[1,] <- sapply(newAuto[, 1:7], mean)\nResults[2,] <- sapply(newAuto[, 1:7], sd)  # Standard Deviation\nResults[3,] <- sapply(newAuto[, 1:7], min)\nResults[4,] <- sapply(newAuto[, 1:7], max)\n\n# Round them\nResults[] <- sapply(Results[],round,2)\n\n# Print the results\n# Results\nprint(Results[,1:6])\n\n          mpg cylinders displacement horsepower  weight acceleration\nMean    24.40      5.37       187.24     100.72 2935.97        15.73\nSD       7.87      1.65        99.68      35.71  811.30         2.69\nMinimum 11.00      3.00        68.00      46.00 1649.00         8.50\nMaximum 46.60      8.00       455.00     230.00 4997.00        24.80\n\n\n9. e) Using the full data set, investigate the predictors graphically, using scatterplots or other tools of your choice. Create some plots highlighting the relationships among the predictors. Comment on your findings.\nAnswer:\n\npairs(Auto[, -9])\n\n\n\n\n\nheavier weight is related with lower mpg and with higher horsepower;\nhigher horsepower correlates with lower acceleration;\nmpg (miles per gallon) mostly increases for newer model years meaning that cars become more efficient over time.\n\n9. f) Suppose that we wish to predict gas mileage (mpg) on the basis of the other variables. Do your plots suggest that any of the other variables might be useful in predicting mpg? Justify your answer.\nAnswer:\nYes. On the one hand, as we can see from the plot above, all of the quantitative variables show some sort of relation (either linear or non-linear) with mpg and hence, they might be useful in predicting mpg. The origin qualitative variable might also be useful in predicting mpg, with cars originated from region 3 being associated with higher mpg. On the other hand, the name predictor has too little observations per name though, so using this as a predictor is likely to result in overfitting the data and will not generalize well."
  }
]